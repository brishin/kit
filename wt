#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "questionary",
#   "click",
# ]
# ///
"""
Unified git worktree management CLI.

Setup: Add these aliases to your ~/.bashrc or ~/.zshrc:
  alias wt-create='eval "$(~/Programming/kit/wt create "$@" 2>&1 1>&3-)" 3>&1'
  alias wt-root='eval "$(~/Programming/kit/wt root 2>&1 1>&3-)" 3>&1'

Usage:
  wt create <branch-name>   Create a git worktree with standardized naming
  wt cleanup                Safely delete current branch and worktree
  wt root                   Navigate to git root directory
"""

import sys
import os
import subprocess
import json
from pathlib import Path

import click
import questionary


def run_command(cmd, capture=True, check=True):
    """Run a shell command and return the result."""
    try:
        if capture:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                check=check
            )
            # When check=False, we still need to return None on failure
            if not check and result.returncode != 0:
                return None
            return result.stdout.strip()
        else:
            # Redirect subprocess stderr to stdout so it doesn't get captured by shell eval
            subprocess.run(cmd, shell=True, check=check, stderr=subprocess.STDOUT)
            return None
    except subprocess.CalledProcessError as e:
        if check:
            return None
        return e.stdout.strip() if e.stdout else None


def check_git_repo():
    """Check if we're in a git repository."""
    result = run_command("git rev-parse --git-dir")
    return result is not None


@click.group()
def cli():
    """Unified git worktree management CLI."""
    pass


@cli.command()
@click.argument("branch_name")
@click.option("--prefix", default="bs", help="Branch prefix (default: bs)")
@click.option("--base", "-b", default="main", help="Base branch to branch from (default: main)")
@click.option("--remote", "-r", is_flag=True, help="Create worktree from existing remote branch")
def create(branch_name, prefix, base, remote):
    """Create a git worktree with standardized naming.

    Example: wt create resend-email
      -> Creates branch: bs/resend-email
      -> Creates worktree at: ./.worktrees/bs-resend-email

    Example with remote: wt create --remote feature-branch
      -> Tracks origin/feature-branch as feature-branch
      -> Creates worktree at: ./.worktrees/feature-branch
    """
    # Check if we're in a git repo
    if not check_git_repo():
        print("‚ùå Error: Not in a git repository")
        sys.exit(1)

    # Get the main repository root (not the current worktree root)
    # git rev-parse --git-common-dir gives us the main .git directory
    git_common_dir = run_command("git rev-parse --git-common-dir")
    if not git_common_dir:
        print("‚ùå Error: Could not determine git directory")
        sys.exit(1)

    # The main repo root is the parent of the .git directory
    git_root = str(Path(git_common_dir).parent.resolve())

    if remote:
        # Remote branch mode: use branch name as-is, no prefix
        full_branch = branch_name
        # Replace slashes with dashes for directory name to avoid nested directories
        worktree_dir_name = branch_name.replace("/", "-")
        worktree_dir = os.path.join(git_root, ".worktrees", worktree_dir_name)

        # Fetch latest from origin to ensure up-to-date refs
        print("üîÑ Fetching from origin...")
        run_command("git fetch origin", capture=False)
        print()

        # Check if branch exists on origin
        remote_ref_check = run_command(
            f"git ls-remote --heads origin refs/heads/{branch_name}",
            check=False
        )
        if not remote_ref_check:
            print(f"‚ùå Error: Branch '{branch_name}' does not exist on origin")
            sys.exit(1)

        print(f"‚úì Found remote branch: origin/{branch_name}")
    else:
        # Regular mode: apply prefix convention
        # Remove any existing prefix if user provided it
        branch_base = branch_name.replace(f"{prefix}/", "")

        # Construct the full branch name and directory (relative to git root)
        full_branch = f"{prefix}/{branch_base}"
        worktree_dir = os.path.join(git_root, ".worktrees", f"{prefix}-{branch_base}")

    print(f"Branch: {full_branch}")
    print(f"Worktree directory: {worktree_dir}")
    print()

    # Check if worktree directory already exists
    if Path(worktree_dir).exists():
        print(f"‚ùå Error: Directory {worktree_dir} already exists")

        # Show existing worktrees
        print("\nExisting worktrees:")
        worktree_list = run_command("git worktree list")
        print(worktree_list if worktree_list else "")
        sys.exit(1)

    # Check if branch already exists locally
    local_branch_exists = run_command(f"git rev-parse --verify {full_branch}", check=False) is not None

    # Check if branch is already checked out in a worktree
    if local_branch_exists:
        worktree_list = run_command("git worktree list --porcelain")
        if worktree_list:
            for line in worktree_list.split('\n'):
                if line.startswith('branch ') and line.split(' ', 1)[1] == f"refs/heads/{full_branch}":
                    print(f"‚ùå Error: Branch {full_branch} is already checked out in a worktree")
                    print("\nExisting worktrees:")
                    print(run_command("git worktree list"))
                    sys.exit(1)

    # Handle remote branch mode
    if remote:
        if local_branch_exists:
            # Both local and remote exist - check if they differ
            local_commit = run_command(f"git rev-parse {full_branch}", check=False)
            remote_commit = run_command(f"git rev-parse origin/{full_branch}", check=False)

            if local_commit != remote_commit:
                print(f"‚ö†Ô∏è  Local branch '{full_branch}' exists but differs from origin/{full_branch}")
                print(f"   Local:  {local_commit[:8] if local_commit else 'unknown'}")
                print(f"   Remote: {remote_commit[:8] if remote_commit else 'unknown'}")
                print()

                choice = questionary.select(
                    "Which version do you want to use?",
                    choices=[
                        "Use local branch",
                        "Use remote branch (reset local to match)",
                        "Abort"
                    ]
                ).ask()

                if choice == "Abort":
                    print("Aborted.")
                    sys.exit(0)
                elif choice == "Use remote branch (reset local to match)":
                    # Reset local to match remote
                    print(f"Resetting local branch '{full_branch}' to match origin/{full_branch}...")
                    run_command(f"git branch -f {full_branch} origin/{full_branch}", capture=False)
                # If "Use local branch", just continue with existing local

            # Create worktree with existing local branch
            cmd = f"git worktree add {worktree_dir} {full_branch}"
        else:
            # No local branch - create it tracking the remote
            cmd = f"git worktree add -b {full_branch} {worktree_dir} origin/{full_branch}"
    else:
        # Regular mode (non-remote)
        if local_branch_exists:
            print(f"‚ö†Ô∏è  Branch {full_branch} already exists")

            use_existing = questionary.confirm(
                "Do you want to create a worktree for the existing branch?",
                default=True
            ).ask()

            if not use_existing:
                print("Aborted.")
                sys.exit(0)

            # Use existing branch (remove -B flag)
            cmd = f"git worktree add {worktree_dir} {full_branch}"
        else:
            # Create new branch based on specified base branch
            cmd = f"git worktree add -B {full_branch} {worktree_dir} {base}"

    # Create the .worktrees directory if it doesn't exist (at repo root)
    worktrees_dir = os.path.join(git_root, ".worktrees")
    os.makedirs(worktrees_dir, exist_ok=True)

    # Run the command
    print("\nüî® Creating worktree...")
    run_command(cmd, capture=False)

    print(f"‚úÖ Worktree created at {worktree_dir}")
    print(f"   Branch: {full_branch}")

    # Check if gt CLI is available and track the branch (only for non-remote branches)
    if not remote and run_command("command -v gt", check=False):
        # Change to worktree directory before running gt track
        os.chdir(worktree_dir)
        # Run gt track with parent set to base branch (default: main)
        run_command(f"gt track --parent {base} --quiet", capture=False, check=False)

    print("   Changing directory...")

    # Output cd command to fd 3 for shell to eval
    # worktree_dir is already an absolute path from os.path.join(git_root, ...)
    try:
        with open('/dev/fd/3', 'w') as fd3:
            fd3.write(f"cd '{worktree_dir}'\n")
    except (OSError, IOError):
        # fd 3 not available, output to stderr as fallback
        print(f"cd '{worktree_dir}'", file=sys.stderr)


@cli.command()
def cleanup():
    """Safely delete current branch and worktree.

    Logic:
    1. Check if branch has unique commits compared to main
    2. If no unique commits -> safe to delete
    3. If has unique commits -> check if PR is merged
    4. If PR is merged -> safe to delete
    5. Otherwise -> keep the branch (print reason)
    """
    # Check if we're in a git repo
    if not check_git_repo():
        print("‚ùå Error: Not in a git repository")
        sys.exit(1)

    # Get current branch name
    current_branch = run_command("git rev-parse --abbrev-ref HEAD")
    if not current_branch:
        print("‚ùå Error: Could not determine current branch")
        sys.exit(1)

    # Don't delete main or master branches
    if current_branch in ["main", "master"]:
        print("‚ùå Cannot delete main/master branch")
        sys.exit(1)

    print(f"Checking if branch '{current_branch}' can be safely deleted...")
    print()

    # Check for uncommitted changes (staged, unstaged, and untracked)
    status_result = run_command("git status --porcelain", check=False)
    if status_result:  # Non-empty means there are changes
        print("‚ö†Ô∏è  Warning: You have uncommitted changes!")
        print("   These changes will be lost if you proceed.")
        print()
        continue_cleanup = questionary.confirm(
            "Continue with cleanup?",
            default=False
        ).ask()
        if not continue_cleanup:
            print("Aborted.")
            sys.exit(0)
        print()

    # Check if branch has unique commits compared to main
    unique_commits = run_command(
        f"git rev-list origin/main..{current_branch} --count",
        check=False
    )
    if unique_commits is None:
        unique_commits = "0"

    if unique_commits == "0":
        print("‚úì No unique commits on this branch")
        print("‚Üí Safe to delete")
        worktree_path = os.getcwd()
        run_command("git checkout --detach origin/main", capture=False)
        run_command(f"git branch -D {current_branch}", capture=False)
        print(f"‚úì Deleted branch '{current_branch}'")
        run_command(f"git worktree remove --force {worktree_path}", capture=False)
        print(f"‚úì Deleted worktree at '{worktree_path}'")
        sys.exit(0)

    print(f"Found {unique_commits} unique commit(s) on this branch")
    print("Checking if associated PR has been merged...")
    print()

    # Check if PR associated with this branch has been merged
    pr_status = run_command(
        f"gh pr list --state merged --head {current_branch} --json number,state,title --jq '.[0]'",
        check=False
    )

    if not pr_status or pr_status == "null":
        print("‚ö†Ô∏è  No merged PR found for this branch")
        print(f"   Branch '{current_branch}' has {unique_commits} unmerged commit(s)")
        print()
        confirm_delete = questionary.confirm(
            "Delete branch and worktree anyway?",
            default=False
        ).ask()
        if not confirm_delete:
            print("Aborted.")
            sys.exit(0)
        print()
        print("‚Üí Proceeding with deletion")
        worktree_path = os.getcwd()
        run_command("git checkout --detach origin/main", capture=False)
        run_command(f"git branch -D {current_branch}", capture=False)
        print(f"‚úì Deleted branch '{current_branch}'")
        run_command(f"git worktree remove --force {worktree_path}", capture=False)
        print(f"‚úì Deleted worktree at '{worktree_path}'")
        sys.exit(0)

    # Extract PR details
    try:
        pr_data = json.loads(pr_status)
        pr_number = pr_data.get("number")
        pr_title = pr_data.get("title")
    except (json.JSONDecodeError, AttributeError):
        print("‚ùå Could not parse PR information")
        print(f"‚Üí Keeping branch '{current_branch}'")
        sys.exit(0)

    print(f"‚úì Found merged PR #{pr_number}: {pr_title}")
    print("‚Üí Safe to delete")
    worktree_path = os.getcwd()
    run_command("git checkout --detach origin/main", capture=False)
    run_command(f"git branch -D {current_branch}", capture=False)
    print(f"‚úì Deleted branch '{current_branch}'")
    run_command(f"git worktree remove --force {worktree_path}", capture=False)
    print(f"‚úì Deleted worktree at '{worktree_path}'")


@cli.command()
def root():
    """Navigate to the git root directory (works with worktrees).

    Usage: Requires shell alias:
      alias wt-root='eval "$(~/Programming/kit/wt root 2>&1 1>&3-)" 3>&1'
    """
    git_root = run_command("git rev-parse --show-toplevel")

    if not git_root:
        print("Error: Not in a git repository", file=sys.stderr)
        sys.exit(1)

    # Output cd command to fd 3 for shell to eval
    try:
        with open('/dev/fd/3', 'w') as fd3:
            fd3.write(f"cd '{git_root}'\n")
    except (OSError, IOError):
        # fd 3 not available, output to stderr as fallback
        print(f"cd '{git_root}'", file=sys.stderr)


if __name__ == "__main__":
    cli()
