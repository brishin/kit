#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "questionary",
#   "click",
#   "gitpython",
# ]
# ///
"""
Unified git worktree management CLI.

Setup: Add these aliases to your ~/.bashrc or ~/.zshrc:
  alias wt-create='eval "$(~/Programming/kit/wt create "$@" 2>&1 1>&3-)" 3>&1'
  alias wt-root='eval "$(~/Programming/kit/wt root 2>&1 1>&3-)" 3>&1'

Usage:
  wt create <branch-name>   Create a git worktree with standardized naming
  wt cleanup                Safely delete current branch and worktree
  wt reuse [branch-name]    Reuse current worktree for a new branch
  wt root                   Navigate to git root directory
"""

import json
import os
import plistlib
import subprocess
import sys
from pathlib import Path

import click
import questionary
from git import Repo
from git.exc import InvalidGitRepositoryError


def get_repo():
    """Get the git repo, returning None if not in a repo."""
    try:
        return Repo(".", search_parent_directories=True)
    except InvalidGitRepositoryError:
        return None


def branch_exists_locally(repo, branch_name):
    """Check if a branch exists locally."""
    return branch_name in [h.name for h in repo.heads]


def branch_exists_on_remote(repo, branch_name, remote_name="origin"):
    """Check if a branch exists on a remote. Fetches first to get latest refs."""
    remote = repo.remotes[remote_name]
    remote.fetch()
    return any(ref.remote_head == branch_name for ref in remote.refs)


def run_command(cmd, capture=True, check=True):
    """Run a shell command and return the result."""
    try:
        if capture:
            result = subprocess.run(
                cmd, shell=True, capture_output=True, text=True, check=check
            )
            # When check=False, we still need to return None on failure
            if not check and result.returncode != 0:
                return None
            return result.stdout.strip()
        else:
            # Redirect subprocess stderr to stdout so it doesn't get captured by shell eval
            subprocess.run(cmd, shell=True, check=check, stderr=subprocess.STDOUT)
            return None
    except subprocess.CalledProcessError as e:
        if check:
            return None
        return e.stdout.strip() if e.stdout else None


def check_git_repo():
    """Check if we're in a git repository."""
    result = run_command("git rev-parse --git-dir")
    return result is not None


class AliasedGroup(click.Group):
    """Click group with command aliases."""

    aliases = {
        "c": "create",
        "cl": "cleanup",
    }

    def get_command(self, ctx, cmd_name):
        rv = super().get_command(ctx, cmd_name)
        if rv is not None:
            return rv
        real_name = self.aliases.get(cmd_name)
        if real_name:
            return super().get_command(ctx, real_name)
        return None


@click.group(cls=AliasedGroup)
def cli():
    """Unified git worktree management CLI."""
    pass


@cli.command()
@click.argument("branch_name")
@click.option("--prefix", default="bs", help="Branch prefix (default: bs)")
@click.option(
    "--base", "-b", default="main", help="Base branch to branch from (default: main)"
)
@click.option(
    "--remote", "-r", is_flag=True, help="Create worktree from existing remote branch"
)
def create(branch_name, prefix, base, remote):
    """Create a git worktree with standardized naming.

    Example: wt create resend-email
      -> Creates branch: bs/resend-email
      -> Creates worktree at: ./.worktrees/bs-resend-email

    Example with remote: wt create --remote feature-branch
      -> Tracks origin/feature-branch as feature-branch
      -> Creates worktree at: ./.worktrees/feature-branch
    """
    # Check if we're in a git repo
    if not check_git_repo():
        print("âŒ Error: Not in a git repository")
        sys.exit(1)

    # Get the main repository root (not the current worktree root)
    # git rev-parse --git-common-dir gives us the main .git directory
    git_common_dir = run_command("git rev-parse --git-common-dir")
    if not git_common_dir:
        print("âŒ Error: Could not determine git directory")
        sys.exit(1)

    # The main repo root is the parent of the .git directory
    git_root = str(Path(git_common_dir).parent.resolve())

    if remote:
        # Remote branch mode: use branch name as-is, no prefix
        full_branch = branch_name
        # Replace slashes with dashes for directory name to avoid nested directories
        worktree_dir_name = branch_name.replace("/", "-")
        worktree_dir = os.path.join(git_root, ".worktrees", worktree_dir_name)

        # Fetch latest from origin to ensure up-to-date refs
        print("ðŸ”„ Fetching from origin...")
        run_command("git fetch origin", capture=False)
        print()

        # Check if branch exists on origin
        remote_ref_check = run_command(
            f"git ls-remote --heads origin refs/heads/{branch_name}", check=False
        )
        if not remote_ref_check:
            print(f"âŒ Error: Branch '{branch_name}' does not exist on origin")
            sys.exit(1)

        print(f"âœ“ Found remote branch: origin/{branch_name}")
    else:
        # Regular mode: apply prefix convention
        # Remove any existing prefix if user provided it
        branch_base = branch_name.replace(f"{prefix}/", "")

        # Construct the full branch name and directory (relative to git root)
        full_branch = f"{prefix}/{branch_base}"
        worktree_dir = os.path.join(git_root, ".worktrees", f"{prefix}-{branch_base}")

    print(f"Branch: {full_branch}")
    print(f"Worktree directory: {worktree_dir}")
    print()

    # Check if worktree directory already exists
    if Path(worktree_dir).exists():
        print(f"âŒ Error: Directory {worktree_dir} already exists")

        # Show existing worktrees
        print("\nExisting worktrees:")
        worktree_list = run_command("git worktree list")
        print(worktree_list if worktree_list else "")
        sys.exit(1)

    # Check if branch already exists locally
    local_branch_exists = (
        run_command(f"git rev-parse --verify {full_branch}", check=False) is not None
    )

    # Check if branch is already checked out in a worktree
    if local_branch_exists:
        worktree_list = run_command("git worktree list --porcelain")
        if worktree_list:
            for line in worktree_list.split("\n"):
                if (
                    line.startswith("branch ")
                    and line.split(" ", 1)[1] == f"refs/heads/{full_branch}"
                ):
                    print(
                        f"âŒ Error: Branch {full_branch} is already checked out in a worktree"
                    )
                    print("\nExisting worktrees:")
                    print(run_command("git worktree list"))
                    sys.exit(1)

    # Handle remote branch mode
    if remote:
        if local_branch_exists:
            # Both local and remote exist - check if they differ
            local_commit = run_command(f"git rev-parse {full_branch}", check=False)
            remote_commit = run_command(
                f"git rev-parse origin/{full_branch}", check=False
            )

            if local_commit != remote_commit:
                print(
                    f"âš ï¸  Local branch '{full_branch}' exists but differs from origin/{full_branch}"
                )
                print(f"   Local:  {local_commit[:8] if local_commit else 'unknown'}")
                print(f"   Remote: {remote_commit[:8] if remote_commit else 'unknown'}")
                print()

                choice = questionary.select(
                    "Which version do you want to use?",
                    choices=[
                        "Use local branch",
                        "Use remote branch (reset local to match)",
                        "Abort",
                    ],
                ).ask()

                if choice == "Abort":
                    print("Aborted.")
                    sys.exit(0)
                elif choice == "Use remote branch (reset local to match)":
                    # Reset local to match remote
                    print(
                        f"Resetting local branch '{full_branch}' to match origin/{full_branch}..."
                    )
                    run_command(
                        f"git branch -f {full_branch} origin/{full_branch}",
                        capture=False,
                    )
                # If "Use local branch", just continue with existing local

            # Create worktree with existing local branch
            cmd = f"git worktree add {worktree_dir} {full_branch}"
        else:
            # No local branch - create it tracking the remote
            cmd = (
                f"git worktree add -b {full_branch} {worktree_dir} origin/{full_branch}"
            )
    else:
        # Regular mode (non-remote)
        if local_branch_exists:
            print(f"âš ï¸  Branch {full_branch} already exists")

            use_existing = questionary.confirm(
                "Do you want to create a worktree for the existing branch?",
                default=True,
            ).ask()

            if not use_existing:
                print("Aborted.")
                sys.exit(0)

            # Use existing branch (remove -B flag)
            cmd = f"git worktree add {worktree_dir} {full_branch}"
        else:
            # Check if base branch exists locally (using GitPython)
            repo = get_repo()
            if not branch_exists_locally(repo, base):
                # Try to fetch from origin
                print(f"âš ï¸  Base branch '{base}' not found locally, checking origin...")
                if not branch_exists_on_remote(repo, base):
                    print(
                        f"âŒ Error: Base branch '{base}' does not exist locally or on origin"
                    )
                    sys.exit(1)

                print(f"âœ“ Found remote branch: origin/{base}")
                # Use origin/{base} as the starting point
                cmd = f"git worktree add -B {full_branch} {worktree_dir} origin/{base}"
            else:
                # Create new branch based on local base branch
                cmd = f"git worktree add -B {full_branch} {worktree_dir} {base}"

    # Create the .worktrees directory if it doesn't exist (at repo root)
    worktrees_dir = os.path.join(git_root, ".worktrees")
    os.makedirs(worktrees_dir, exist_ok=True)

    # Run the command
    print("\nðŸ”¨ Creating worktree...")
    run_command(cmd, capture=False)

    print(f"âœ… Worktree created at {worktree_dir}")
    print(f"   Branch: {full_branch}")

    # Check if gt CLI is available and track the branch (only for non-remote branches)
    if not remote and run_command("command -v gt", check=False):
        # Change to worktree directory before running gt track
        os.chdir(worktree_dir)
        # Run gt track with parent set to base branch (default: main)
        run_command(f"gt track --parent {base} --quiet", capture=False, check=False)

    print("   Changing directory...")

    # Output cd command to fd 3 for shell to eval
    # worktree_dir is already an absolute path from os.path.join(git_root, ...)
    try:
        with open("/dev/fd/3", "w") as fd3:
            fd3.write(f"cd '{worktree_dir}'\n")
    except (OSError, IOError):
        # fd 3 not available, output to stderr as fallback
        print(f"cd '{worktree_dir}'", file=sys.stderr)


def cleanup_derived_data(worktree_path: str) -> None:
    """Spawn a background process to delete DerivedData folders for this worktree."""
    derived_data_dir = Path.home() / "Library" / "Developer" / "Xcode" / "DerivedData"
    if not derived_data_dir.is_dir():
        return

    matching: list[Path] = []
    for entry in derived_data_dir.iterdir():
        info_plist = entry / "info.plist"
        if not info_plist.is_file():
            continue
        try:
            with open(info_plist, "rb") as f:
                data = plistlib.load(f)
            workspace_path = data.get("WorkspacePath", "")
            try:
                Path(workspace_path).relative_to(worktree_path)
                matching.append(entry)
            except ValueError:
                pass
        except Exception:
            pass

    if not matching:
        return

    print(f"Cleaning up {len(matching)} DerivedData folder(s) in background...")
    paths = [str(p) for p in matching]
    script = (
        "import shutil, sys\n"
        "for p in sys.argv[1:]:\n"
        "    shutil.rmtree(p, ignore_errors=True)\n"
    )
    subprocess.Popen(
        [sys.executable, "-c", script, *paths],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
        start_new_session=True,
    )


@cli.command()
def cleanup():
    """Safely delete current branch and worktree.

    Logic:
    1. Check if branch has unique commits compared to main
    2. If no unique commits -> safe to delete
    3. If has unique commits -> check if PR is merged
    4. If PR is merged -> safe to delete
    5. Otherwise -> keep the branch (print reason)
    """
    # Check if we're in a git repo
    if not check_git_repo():
        print("âŒ Error: Not in a git repository")
        sys.exit(1)

    # Get current branch name
    current_branch = run_command("git rev-parse --abbrev-ref HEAD")
    if not current_branch:
        print("âŒ Error: Could not determine current branch")
        sys.exit(1)

    # Don't delete main or master branches
    if current_branch in ["main", "master"]:
        print("âŒ Cannot delete main/master branch")
        sys.exit(1)

    # Check if we're in a worktree (not the main repo)
    cwd = os.getcwd()
    if "/.worktrees/" not in cwd:
        print("âŒ Cannot cleanup from main worktree")
        print("   This command is only for cleaning up worktrees in .worktrees/")
        sys.exit(1)

    print(f"Checking if branch '{current_branch}' can be safely deleted...")
    print()

    # Check for uncommitted changes (staged, unstaged, and untracked)
    status_result = run_command("git status --porcelain", check=False)
    if status_result:  # Non-empty means there are changes
        print("âš ï¸  Warning: You have uncommitted changes!")
        print("   These changes will be lost if you proceed.")
        print()
        continue_cleanup = questionary.confirm(
            "Continue with cleanup?", default=False
        ).ask()
        if not continue_cleanup:
            print("Aborted.")
            sys.exit(0)
        print()

    # Check if branch has unique commits compared to main
    unique_commits = run_command(
        f"git rev-list origin/main..{current_branch} --count", check=False
    )
    if unique_commits is None:
        unique_commits = "0"

    if unique_commits == "0":
        print("âœ“ No unique commits on this branch")
        print("â†’ Safe to delete")
        worktree_path = os.getcwd()
        run_command("git checkout --detach origin/main", capture=False)
        run_command(f"git branch -D {current_branch}", capture=False)
        print(f"âœ“ Deleted branch '{current_branch}'")
        run_command(f"git worktree remove --force {worktree_path}", capture=False)
        print(f"âœ“ Deleted worktree at '{worktree_path}'")
        cleanup_derived_data(worktree_path)
        sys.exit(0)

    print(f"Found {unique_commits} unique commit(s) on this branch")
    print("Checking if associated PR has been merged...")
    print()

    # Check if PR associated with this branch has been merged
    pr_status = run_command(
        f"gh pr list --state merged --head {current_branch} --json number,state,title --jq '.[0]'",
        check=False,
    )

    if not pr_status or pr_status == "null":
        print("âš ï¸  No merged PR found for this branch")
        print(f"   Branch '{current_branch}' has {unique_commits} unmerged commit(s)")
        print()
        confirm_delete = questionary.confirm(
            "Delete branch and worktree anyway?", default=False
        ).ask()
        if not confirm_delete:
            print("Aborted.")
            sys.exit(0)
        print()
        print("â†’ Proceeding with deletion")
        worktree_path = os.getcwd()
        run_command("git checkout --detach origin/main", capture=False)
        run_command(f"git branch -D {current_branch}", capture=False)
        print(f"âœ“ Deleted branch '{current_branch}'")
        run_command(f"git worktree remove --force {worktree_path}", capture=False)
        print(f"âœ“ Deleted worktree at '{worktree_path}'")
        cleanup_derived_data(worktree_path)
        sys.exit(0)

    # Extract PR details
    try:
        pr_data = json.loads(pr_status)
        pr_number = pr_data.get("number")
        pr_title = pr_data.get("title")
    except (json.JSONDecodeError, AttributeError):
        print("âŒ Could not parse PR information")
        print(f"â†’ Keeping branch '{current_branch}'")
        sys.exit(0)

    print(f"âœ“ Found merged PR #{pr_number}: {pr_title}")
    print("â†’ Safe to delete")
    worktree_path = os.getcwd()
    run_command("git checkout --detach origin/main", capture=False)
    run_command(f"git branch -D {current_branch}", capture=False)
    print(f"âœ“ Deleted branch '{current_branch}'")
    run_command(f"git worktree remove --force {worktree_path}", capture=False)
    print(f"âœ“ Deleted worktree at '{worktree_path}'")
    cleanup_derived_data(worktree_path)


@cli.command()
@click.argument("branch_name", required=False)
@click.option("--prefix", default="bs", help="Branch prefix (default: bs)")
@click.option(
    "--base", "-b", default="main", help="Base branch to branch from (default: main)"
)
def reuse(branch_name, prefix, base):
    """Reuse current worktree directory for a new branch.

    This command:
    1. Checks if current branch can be safely deleted (like cleanup)
    2. Prompts for new branch name if not provided
    3. Deletes old branch and creates new branch in same worktree

    Example: wt reuse new-feature
      -> Deletes current branch
      -> Creates branch: bs/new-feature in current worktree
    """
    if not check_git_repo():
        print("âŒ Error: Not in a git repository")
        sys.exit(1)

    current_branch = run_command("git rev-parse --abbrev-ref HEAD")
    if not current_branch:
        print("âŒ Error: Could not determine current branch")
        sys.exit(1)

    if current_branch in ["main", "master"]:
        print("âŒ Cannot reuse main/master branch")
        sys.exit(1)

    # Check if we're in a worktree (not the main repo)
    cwd = os.getcwd()
    if "/.worktrees/" not in cwd:
        print("âŒ Cannot reuse from main worktree")
        print("   This command is only for reusing worktrees in .worktrees/")
        sys.exit(1)

    print(f"Current branch: {current_branch}")
    print("Checking if branch can be safely reused...")
    print()

    status_result = run_command("git status --porcelain", check=False)
    if status_result:
        print("âš ï¸  Warning: You have uncommitted changes!")
        print("   These changes will be lost if you proceed.")
        print()
        continue_reuse = questionary.confirm(
            "Continue with reuse?", default=False
        ).ask()
        if not continue_reuse:
            print("Aborted.")
            sys.exit(0)
        print()

    unique_commits = run_command(
        f"git rev-list origin/{base}..{current_branch} --count", check=False
    )
    if unique_commits is None:
        unique_commits = "0"

    if unique_commits != "0":
        print(f"Found {unique_commits} unique commit(s) on this branch")
        print("Checking if associated PR has been merged...")
        print()

        pr_status = run_command(
            f"gh pr list --state merged --head {current_branch} --json number,state,title --jq '.[0]'",
            check=False,
        )

        if not pr_status or pr_status == "null":
            print("âš ï¸  No merged PR found for this branch")
            print(
                f"   Branch '{current_branch}' has {unique_commits} unmerged commit(s)"
            )
            print()
            confirm_reuse = questionary.confirm(
                "Reuse worktree anyway? (unmerged work will be lost)", default=False
            ).ask()
            if not confirm_reuse:
                print("Aborted.")
                sys.exit(0)
            print()
        else:
            try:
                pr_data = json.loads(pr_status)
                pr_number = pr_data.get("number")
                pr_title = pr_data.get("title")
                print(f"âœ“ Found merged PR #{pr_number}: {pr_title}")
                print()
            except (json.JSONDecodeError, AttributeError):
                print("âš ï¸  Could not parse PR information")
                print()

    if not branch_name:
        branch_name = questionary.text(
            "Enter new branch name:",
            validate=lambda text: len(text) > 0 or "Branch name cannot be empty",
        ).ask()

        if not branch_name:
            print("Aborted.")
            sys.exit(0)

    branch_base = branch_name.replace(f"{prefix}/", "")
    full_branch = f"{prefix}/{branch_base}"

    branch_exists = (
        run_command(f"git rev-parse --verify {full_branch}", check=False) is not None
    )
    if branch_exists:
        print(f"âŒ Error: Branch '{full_branch}' already exists")
        sys.exit(1)

    print(f"â†’ Reusing worktree for new branch: {full_branch}")
    print()

    worktree_path = os.getcwd()

    print(f"Checking out {base}...")
    run_command(f"git checkout --detach origin/{base}", capture=False)

    print(f"Deleting old branch '{current_branch}'...")
    run_command(f"git branch -D {current_branch}", capture=False)

    print(f"Creating new branch '{full_branch}'...")
    run_command(f"git checkout -b {full_branch}", capture=False)

    print()
    print("âœ… Worktree reused successfully")
    print(f"   Old branch: {current_branch} (deleted)")
    print(f"   New branch: {full_branch}")
    print(f"   Location: {worktree_path}")

    if run_command("command -v gt", check=False):
        run_command(f"gt track --parent {base} --quiet", capture=False, check=False)


@cli.command()
def root():
    """Navigate to the git root directory (works with worktrees).

    Usage: Requires shell alias:
      alias wt-root='eval "$(~/Programming/kit/wt root 2>&1 1>&3-)" 3>&1'
    """
    git_root = run_command("git rev-parse --show-toplevel")

    if not git_root:
        print("Error: Not in a git repository", file=sys.stderr)
        sys.exit(1)

    # Output cd command to fd 3 for shell to eval
    try:
        with open("/dev/fd/3", "w") as fd3:
            fd3.write(f"cd '{git_root}'\n")
    except (OSError, IOError):
        # fd 3 not available, output to stderr as fallback
        print(f"cd '{git_root}'", file=sys.stderr)


if __name__ == "__main__":
    cli()
