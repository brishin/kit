#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "questionary",
#   "click",
# ]
# ///
"""
Unified git worktree management CLI.

Setup: Add these aliases to your ~/.bashrc or ~/.zshrc:
  alias wt-create='eval "$(~/Programming/brian-scripts/wt create "$@" 2>&1 1>&3-)" 3>&1'
  alias wt-root='eval "$(~/Programming/brian-scripts/wt root 2>&1 1>&3-)" 3>&1'

Usage:
  wt create <branch-name>   Create a git worktree with standardized naming
  wt cleanup                Safely delete current branch and worktree
  wt root                   Navigate to git root directory
"""

import sys
import os
import subprocess
import json
from pathlib import Path

import click
import questionary


def run_command(cmd, capture=True, check=True):
    """Run a shell command and return the result."""
    try:
        if capture:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                check=check
            )
            return result.stdout.strip()
        else:
            # Redirect subprocess stderr to stdout so it doesn't get captured by shell eval
            subprocess.run(cmd, shell=True, check=check, stderr=subprocess.STDOUT)
            return None
    except subprocess.CalledProcessError as e:
        if check:
            return None
        return e.stdout.strip() if e.stdout else None


def check_git_repo():
    """Check if we're in a git repository."""
    result = run_command("git rev-parse --git-dir")
    return result is not None


@click.group()
def cli():
    """Unified git worktree management CLI."""
    pass


@cli.command()
@click.argument("branch_name")
@click.option("--prefix", default="bs", help="Branch prefix (default: bs)")
def create(branch_name, prefix):
    """Create a git worktree with standardized naming.

    Example: wt create resend-email
      -> Creates branch: bs/resend-email
      -> Creates worktree at: ./.conductor/bs-resend-email
    """
    # Remove any existing prefix if user provided it
    branch_base = branch_name.replace(f"{prefix}/", "")

    # Construct the full branch name and directory
    full_branch = f"{prefix}/{branch_base}"
    worktree_dir = f"./.conductor/{prefix}-{branch_base}"

    print(f"Branch: {full_branch}")
    print(f"Worktree directory: {worktree_dir}")
    print()

    # Check if we're in a git repo
    if not check_git_repo():
        print("❌ Error: Not in a git repository")
        sys.exit(1)

    # Check if worktree directory already exists
    if Path(worktree_dir).exists():
        print(f"❌ Error: Directory {worktree_dir} already exists")

        # Show existing worktrees
        print("\nExisting worktrees:")
        worktree_list = run_command("git worktree list")
        print(worktree_list if worktree_list else "")
        sys.exit(1)

    # Check if branch already exists
    branch_exists = run_command(f"git rev-parse --verify {full_branch}") is not None
    if branch_exists:
        print(f"⚠️  Branch {full_branch} already exists")

        use_existing = questionary.confirm(
            "Do you want to use the existing branch?",
            default=True
        ).ask()

        if not use_existing:
            print("Aborted.")
            sys.exit(0)

        # Use existing branch (remove -B flag)
        cmd = f"git worktree add {worktree_dir} {full_branch}"
    else:
        # Create new branch
        cmd = f"git worktree add -B {full_branch} {worktree_dir}"

    # Create the .conductor directory if it doesn't exist
    os.makedirs(".conductor", exist_ok=True)

    # Run the command
    print("\n🔨 Creating worktree...")
    run_command(cmd, capture=False)

    print(f"✅ Worktree created at {worktree_dir}")
    print(f"   Branch: {full_branch}")
    print("   Changing directory...")

    # Output cd command to fd 3 for shell to eval
    abs_path = os.path.abspath(worktree_dir)
    try:
        with open('/dev/fd/3', 'w') as fd3:
            fd3.write(f"cd '{abs_path}'\n")
    except (OSError, IOError):
        # fd 3 not available, output to stderr as fallback
        print(f"cd '{abs_path}'", file=sys.stderr)


@cli.command()
def cleanup():
    """Safely delete current branch and worktree.

    Logic:
    1. Check if branch has unique commits compared to main
    2. If no unique commits -> safe to delete
    3. If has unique commits -> check if PR is merged
    4. If PR is merged -> safe to delete
    5. Otherwise -> keep the branch (print reason)
    """
    # Check if we're in a git repo
    if not check_git_repo():
        print("❌ Error: Not in a git repository")
        sys.exit(1)

    # Get current branch name
    current_branch = run_command("git rev-parse --abbrev-ref HEAD")
    if not current_branch:
        print("❌ Error: Could not determine current branch")
        sys.exit(1)

    # Don't delete main or master branches
    if current_branch in ["main", "master"]:
        print("❌ Cannot delete main/master branch")
        sys.exit(1)

    print(f"Checking if branch '{current_branch}' can be safely deleted...")
    print()

    # Check for uncommitted changes
    diff_result = run_command("git diff-index --quiet HEAD", check=False)
    if diff_result is None:  # Command failed, means there are changes
        print("⚠ Warning: Uncommitted changes detected")
        print("  These changes will not be preserved")
        print()

    # Check if branch has unique commits compared to main
    unique_commits = run_command(
        f"git rev-list origin/main..{current_branch} --count",
        check=False
    )
    if unique_commits is None:
        unique_commits = "0"

    if unique_commits == "0":
        print("✓ No unique commits on this branch")
        print("→ Safe to delete")
        worktree_path = os.getcwd()
        run_command("git checkout --detach origin/main", capture=False)
        run_command(f"git branch -D {current_branch}", capture=False)
        print(f"✓ Deleted branch '{current_branch}'")
        run_command(f"git worktree remove {worktree_path}", capture=False)
        print(f"✓ Deleted worktree at '{worktree_path}'")
        sys.exit(0)

    print(f"Found {unique_commits} unique commit(s) on this branch")
    print("Checking if associated PR has been merged...")
    print()

    # Check if PR associated with this branch has been merged
    pr_status = run_command(
        f"gh pr list --state merged --head {current_branch} --json number,state,title --jq '.[0]'",
        check=False
    )

    if not pr_status or pr_status == "null":
        print("❌ No merged PR found for this branch")
        print(f"→ Keeping branch '{current_branch}' (has unmerged commits)")
        sys.exit(0)

    # Extract PR details
    try:
        pr_data = json.loads(pr_status)
        pr_number = pr_data.get("number")
        pr_title = pr_data.get("title")
    except (json.JSONDecodeError, AttributeError):
        print("❌ Could not parse PR information")
        print(f"→ Keeping branch '{current_branch}'")
        sys.exit(0)

    print(f"✓ Found merged PR #{pr_number}: {pr_title}")
    print("→ Safe to delete")
    worktree_path = os.getcwd()
    run_command("git checkout --detach origin/main", capture=False)
    run_command(f"git branch -D {current_branch}", capture=False)
    print(f"✓ Deleted branch '{current_branch}'")
    run_command(f"git worktree remove {worktree_path}", capture=False)
    print(f"✓ Deleted worktree at '{worktree_path}'")


@cli.command()
def root():
    """Navigate to the git root directory (works with worktrees).

    Usage: Requires shell alias:
      alias wt-root='eval "$(~/Programming/brian-scripts/wt root 2>&1 1>&3-)" 3>&1'
    """
    git_root = run_command("git rev-parse --show-toplevel")

    if not git_root:
        print("Error: Not in a git repository", file=sys.stderr)
        sys.exit(1)

    # Output cd command to fd 3 for shell to eval
    try:
        with open('/dev/fd/3', 'w') as fd3:
            fd3.write(f"cd '{git_root}'\n")
    except (OSError, IOError):
        # fd 3 not available, output to stderr as fallback
        print(f"cd '{git_root}'", file=sys.stderr)


if __name__ == "__main__":
    cli()
