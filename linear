#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "gql[requests]>=3.5.0",
#   "click",
#   "questionary",
#   "python-dotenv",
# ]
# ///
"""
Linear CLI - Manage Linear issues and comments from the command line.

Powered by the Linear GraphQL API.

Usage:
  linear issue list [--assignee USER] [--status STATUS] [--label LABEL]
  linear issue view <issue-id>
  linear issue create
  linear issue update <issue-id> [--status STATUS] [--assignee USER] [--title TITLE]
  linear comment list <issue-id>
  linear comment create <issue-id> [--message MESSAGE]

Setup:
  1. Generate a Personal API Key at: https://linear.app/settings/api
  2. Add to ~/.env.local: LINEAR_API_KEY="lin_api_..."
     (or set environment variable: export LINEAR_API_KEY="lin_api_...")
"""

import sys
import os
from pathlib import Path
from typing import TypedDict, Optional, List, Any, NotRequired

import click
import questionary
from dotenv import load_dotenv
from gql import Client, gql as gql_query
from gql.transport.requests import RequestsHTTPTransport
from gql.transport.exceptions import TransportQueryError

# Load environment variables from ~/.env.local
load_dotenv(dotenv_path=Path.home() / ".env.local")


# ============================================================================
# Type Definitions
# ============================================================================

# Priority is a scalar number (0-4), with separate priorityLabel field


class StatusData(TypedDict):
    id: str
    name: str
    type: NotRequired[str]  # "unstarted", "started", "completed", "canceled"


class UserData(TypedDict):
    id: str
    name: str
    email: NotRequired[str]


class AttachmentData(TypedDict):
    id: str
    title: str
    subtitle: NotRequired[str]
    url: str


class AttachmentsConnection(TypedDict):
    nodes: List[AttachmentData]


class IssueRef(TypedDict):
    """Minimal issue reference (for parent/children)"""
    id: str
    identifier: str
    title: NotRequired[str]
    status: NotRequired[StatusData]
    priority: NotRequired[float]
    priorityLabel: NotRequired[str]
    attachments: NotRequired[AttachmentsConnection]


class ChildrenConnection(TypedDict):
    nodes: List[IssueRef]


class IssueData(TypedDict):
    id: str
    identifier: str
    title: str
    description: NotRequired[str]
    priority: NotRequired[float]  # 0-4, where 0 is no priority, 1 is urgent, 4 is low
    priorityLabel: NotRequired[str]  # "Urgent", "High", "Medium", "Low", "No priority"
    status: StatusData
    url: str
    branchName: NotRequired[str]
    createdAt: str
    updatedAt: str
    assignee: NotRequired[UserData]
    creator: NotRequired[UserData]
    project: NotRequired[dict[str, str]]
    team: NotRequired[dict[str, str]]
    parent: NotRequired[IssueRef]
    children: NotRequired[ChildrenConnection]
    attachments: NotRequired[AttachmentsConnection]


class CommentData(TypedDict):
    id: str
    body: str
    createdAt: str
    user: UserData


class TeamData(TypedDict):
    id: str
    name: str
    key: str


# ============================================================================
# GraphQL Client
# ============================================================================

_client_cache: Optional[Client] = None


def get_client() -> Client:
    """Get or create GraphQL client connection."""
    global _client_cache

    if _client_cache is not None:
        return _client_cache

    api_key = os.environ.get("LINEAR_API_KEY")
    if not api_key:
        click.echo("Error: LINEAR_API_KEY not found", err=True)
        click.echo("\nTo get an API key:", err=True)
        click.echo("  1. Go to https://linear.app/settings/api", err=True)
        click.echo("  2. Create a new Personal API Key", err=True)
        click.echo("  3. Add to ~/.env.local: LINEAR_API_KEY='lin_api_...'", err=True)
        click.echo("     (or set environment variable: export LINEAR_API_KEY='lin_api_...')", err=True)
        sys.exit(1)

    # Create transport with API key authentication
    transport = RequestsHTTPTransport(
        url="https://api.linear.app/graphql",
        headers={"Authorization": api_key},
        verify=True,
        retries=3,
    )

    # Create and cache the client
    _client_cache = Client(transport=transport, fetch_schema_from_transport=False)
    return _client_cache


# ============================================================================
# GraphQL Queries
# ============================================================================

LIST_ISSUES_QUERY = gql_query("""
query ListIssues($first: Int!) {
  issues(first: $first, orderBy: updatedAt) {
    nodes {
      id
      identifier
      title
      description
      status: state { id name }
      priority
      priorityLabel
      url
      parent { id identifier title }
      children(first: 50) {
        nodes {
          id
          identifier
        }
      }
      attachments {
        nodes {
          id
          title
          subtitle
          url
        }
      }
      assignee { id name }
      createdAt
      updatedAt
      project { id name }
      team { name }
    }
  }
}
""")

GET_ISSUE_QUERY = gql_query("""
query GetIssue($id: String!) {
  issue(id: $id) {
    id
    identifier
    title
    description
    status: state { id name }
    priority
    priorityLabel
    url
    branchName
    createdAt
    updatedAt
    parent { id identifier title }
    children(first: 50) {
      nodes {
        id
        identifier
        title
        status: state { id name type }
        priority
        priorityLabel
        attachments {
          nodes {
            id
            title
            subtitle
            url
          }
        }
      }
    }
    attachments {
      nodes {
        id
        title
        subtitle
        url
      }
    }
    assignee { id name email }
    creator { name }
    project { name }
    team { name }
  }
}
""")

LIST_COMMENTS_QUERY = gql_query("""
query ListComments($issueId: String!) {
  issue(id: $issueId) {
    comments {
      nodes {
        id
        body
        createdAt
        user { id name }
      }
    }
  }
}
""")

CREATE_ISSUE_MUTATION = gql_query("""
mutation CreateIssue($input: IssueCreateInput!) {
  issueCreate(input: $input) {
    success
    issue {
      id
      identifier
      title
      description
      status: state { id name }
      priority
      priorityLabel
    }
  }
}
""")

UPDATE_ISSUE_MUTATION = gql_query("""
mutation UpdateIssue($id: String!, $input: IssueUpdateInput!) {
  issueUpdate(id: $id, input: $input) {
    success
    issue {
      id
      identifier
      title
      description
      status: state { id name }
      priority
      priorityLabel
    }
  }
}
""")

CREATE_COMMENT_MUTATION = gql_query("""
mutation CreateComment($input: CommentCreateInput!) {
  commentCreate(input: $input) {
    success
    comment {
      id
      body
      createdAt
      user { id name }
    }
  }
}
""")

LIST_TEAMS_QUERY = gql_query("""
query ListTeams {
  teams {
    nodes {
      id
      name
      key
    }
  }
}
""")


# ============================================================================
# Helper Functions
# ============================================================================

def resolve_issue_id(client: Client, identifier_or_id: str) -> str:
    """
    Resolve a human-readable identifier (e.g., 'FLA-123') to a UUID.
    If already a UUID, returns it as-is.
    """
    # Check if it's already a UUID (contains only hex chars and dashes)
    if all(c in '0123456789abcdef-' for c in identifier_or_id.lower()):
        return identifier_or_id

    # It's a human-readable identifier, fetch from Linear directly
    # Linear's issue() query accepts identifiers directly
    search_query = gql_query("""
    query GetIssueByIdentifier($id: String!) {
      issue(id: $id) {
        id
        identifier
      }
    }
    """)

    try:
        result = client.execute(search_query, variable_values={"id": identifier_or_id})
        issue = result.get("issue")

        if issue and issue.get("id"):
            return str(issue["id"])

        raise ValueError(f"Could not find issue with identifier: {identifier_or_id}")

    except Exception as e:
        raise ValueError(f"Error resolving issue identifier '{identifier_or_id}': {e}")


def get_priority_icon(priority: Optional[float]) -> str:
    """Get emoji icon for priority level."""
    if priority is None or priority == 0:
        return "âšª"  # No priority

    if priority == 1:
        return "ðŸ”´"  # Urgent
    elif priority == 2:
        return "ðŸŸ "  # High
    elif priority == 3:
        return "ðŸŸ¡"  # Medium
    elif priority == 4:
        return "ðŸŸ¢"  # Low
    else:
        return "âšª"  # Unknown


def count_pr_attachments(attachments: Optional[AttachmentsConnection]) -> int:
    """Count GitHub PR attachments."""
    if not attachments:
        return 0

    nodes = attachments.get("nodes", [])
    return sum(1 for att in nodes if "github.com" in att.get("url", ""))


def count_subissues(children: Optional[ChildrenConnection]) -> int:
    """Count child issues (subissues)."""
    if not children:
        return 0
    return len(children.get("nodes", []))


def sort_issues_by_status(issues: List[IssueRef]) -> List[IssueRef]:
    """
    Sort issues by status type, with completed/canceled at the bottom.

    Order: unstarted -> started -> canceled -> completed
    Within each group, sort by most recently updated first.
    """
    # Define sort order for state types
    state_type_order = {
        "unstarted": 0,
        "started": 1,
        "canceled": 2,
        "completed": 3,
    }

    def get_sort_key(issue: IssueRef) -> tuple[int, str]:
        status = issue.get("status")
        state_type = status.get("type", "unstarted") if status else "unstarted"

        # Get priority for state type (lower is higher priority)
        type_priority = state_type_order.get(state_type, 999)

        # Return tuple: (state_type_priority, negative to sort desc by update time if available)
        return (type_priority, "")

    return sorted(issues, key=get_sort_key)


def format_issue_compact(issue_data: IssueData | IssueRef, max_title_len: int = 40, show_parent_project: bool = True) -> str:
    """Format issue in compact one-line view."""
    issue_id = issue_data.get("identifier", "unknown")
    title = issue_data.get("title", "No title")
    status_obj = issue_data.get("status")
    status = status_obj.get("name", "unknown") if status_obj else "unknown"
    priority = issue_data.get("priority")

    priority_icon = get_priority_icon(priority)

    # Truncate title to fit
    title_display = title[:max_title_len] + "..." if len(title) > max_title_len else title

    # Build compact display
    parts = [
        f"[{issue_id}]",
        f"[{status}]",
        f"[{priority_icon}]",
        title_display,
    ]

    # Add metadata indicators (only for full IssueData)
    meta_parts = []

    # Add PR and subissue counts
    # Both IssueData and IssueRef can have attachments field
    attachments_field = issue_data.get("attachments")
    if attachments_field is not None:
        pr_count = count_pr_attachments(attachments_field)
        if pr_count > 0:
            meta_parts.append(f"PRs: {pr_count}")

    children_field = issue_data.get("children")
    if children_field is not None:
        sub_count = count_subissues(children_field)  # type: ignore
        if sub_count > 0:
            meta_parts.append(f"Subs: {sub_count} â†³")

    # Add parent info if available and requested
    if show_parent_project:
        parent = issue_data.get("parent")
        if parent and isinstance(parent, dict):
            parent_id = parent.get("identifier", "unknown")
            meta_parts.append(f"Parent: {parent_id}")

        # Add project info if available
        project = issue_data.get("project")
        if project and isinstance(project, dict):
            project_name = project.get("name")
            if project_name:
                meta_parts.append(f"Project: {project_name}")

    if meta_parts:
        parts.append(f"| {' | '.join(meta_parts)}")

    return " ".join(parts)


def format_issue(issue_data: IssueData, detailed: bool = False) -> str:
    """Format issue data for display."""
    issue_id = issue_data.get("identifier", "unknown")
    title = issue_data.get("title", "No title")
    status = issue_data.get("status", {}).get("name", "unknown")
    priority = issue_data.get("priority")

    if detailed:
        # Detailed view
        assignee = issue_data.get("assignee")
        assignee_name = assignee.get("name", "Unassigned") if assignee else "Unassigned"

        description = issue_data.get("description", "No description")
        created_at = issue_data.get("createdAt", "unknown")
        updated_at = issue_data.get("updatedAt", "unknown")
        priority_label = issue_data.get("priorityLabel", "No priority")

        # Parent issue
        parent = issue_data.get("parent")
        parent_str = f"{parent['identifier']}" if parent else "None"

        # Project
        project = issue_data.get("project")
        project_str = project.get("name") if project and isinstance(project, dict) else "None"

        # Children (subissues)
        children_nodes = issue_data.get("children", {}).get("nodes", [])
        # Sort children by status (done/canceled at bottom)
        children_sorted = sort_issues_by_status(children_nodes)

        # PR attachments
        attachments = issue_data.get("attachments", {}).get("nodes", [])
        pr_links = [att["url"] for att in attachments if "github.com" in att.get("url", "")]

        output = []
        output.append(f"\n{issue_id}: {title}")
        output.append("=" * 80)
        output.append(f"Status: {status}")
        output.append(f"Priority: {priority_label}")
        output.append(f"Assignee: {assignee_name}")
        output.append(f"Project: {project_str}")
        output.append(f"Parent: {parent_str}")
        output.append(f"Created: {created_at}")
        output.append(f"Updated: {updated_at}")

        if children_sorted:
            output.append(f"\nSubissues ({len(children_sorted)}):")
            for child in children_sorted:
                # Don't show parent/project for subissues (redundant in this context)
                output.append(f"  {format_issue_compact(child, max_title_len=60, show_parent_project=False)}")

                # Show PRs for this subissue as indented lines
                child_attachments = child.get("attachments", {}).get("nodes", []) if isinstance(child.get("attachments"), dict) else []
                child_pr_links = [att["url"] for att in child_attachments if "github.com" in att.get("url", "")]
                for pr_url in child_pr_links:
                    output.append(f"    â†’ {pr_url}")

        if pr_links:
            output.append(f"\nPull Requests:")
            for pr in pr_links:
                output.append(f"  - {pr}")

        output.append(f"\nDescription:")
        output.append(description or "(none)")
        output.append("=" * 80)

        return "\n".join(output)
    else:
        # Compact list view - show parent and project
        return format_issue_compact(issue_data, show_parent_project=True)


def format_comment(comment_data: CommentData) -> str:
    """Format comment data for display."""
    user = comment_data.get("user", {})
    author_name = user.get("name", "Unknown")
    body = comment_data.get("body", "")
    created_at = comment_data.get("createdAt", "unknown")

    return f"\n[{author_name}] {created_at}\n{body}\n{'-' * 40}"


# ============================================================================
# CLI Commands
# ============================================================================

@click.group()
def cli() -> None:
    """Linear CLI - Manage Linear issues and comments."""
    pass


@cli.group()
def issue() -> None:
    """Manage Linear issues."""
    pass


@cli.group()
def comment() -> None:
    """Manage issue comments."""
    pass


@issue.command("list")
@click.option("--assignee", help="Filter by assignee user ID or name")
@click.option("--state", help="Filter by state (status)")
@click.option("--label", help="Filter by label")
@click.option("--team", help="Filter by team key")
@click.option("--limit", type=int, default=50, help="Maximum number of issues to return (default: 50)")
def issue_list(
    assignee: Optional[str],
    state: Optional[str],
    label: Optional[str],
    team: Optional[str],
    limit: int,
) -> None:
    """List Linear issues with optional filtering."""
    client = get_client()

    try:
        # TODO: Add support for filters (assignee, state, label, team)
        # Linear's GraphQL API has complex filter syntax that needs to be handled properly
        if any([assignee, state, label, team]):
            click.echo("Note: Filtering options are not yet implemented. Showing all issues.", err=True)

        # Execute query
        variables: dict[str, Any] = {"first": limit}
        result = client.execute(LIST_ISSUES_QUERY, variable_values=variables)
        issues = result.get("issues", {}).get("nodes", [])

        if not issues:
            click.echo("No issues found.")
            return

        # Display issues
        click.echo()
        for issue in issues:
            click.echo(format_issue(issue, detailed=False))

        click.echo(f"\nShowing {len(issues)} issue(s)")

    except TransportQueryError as e:
        click.echo(f"Error: GraphQL query failed: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


@issue.command("view")
@click.argument("issue_id")
def issue_view(issue_id: str) -> None:
    """View detailed information about a specific issue."""
    client = get_client()

    try:
        # Resolve human-readable identifier to UUID if needed
        resolved_id = resolve_issue_id(client, issue_id)

        # Execute query
        result = client.execute(GET_ISSUE_QUERY, variable_values={"id": resolved_id})
        issue = result.get("issue")

        if not issue:
            click.echo(f"Error: Issue {issue_id} not found", err=True)
            sys.exit(1)

        click.echo(format_issue(issue, detailed=True))

    except TransportQueryError as e:
        click.echo(f"Error: Issue not found or access denied: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


@issue.command("create")
@click.option("--title", help="Issue title")
@click.option("--description", help="Issue description")
@click.option("--team", help="Team ID or key (e.g., FLA)")
@click.option("--parent", help="Parent issue ID (to create a subtask)")
@click.option("--assignee", help="Assignee user ID")
@click.option("--priority", type=int, help="Priority (0-4)")
def issue_create(
    title: Optional[str],
    description: Optional[str],
    team: Optional[str],
    parent: Optional[str],
    assignee: Optional[str],
    priority: Optional[int],
) -> None:
    """Create a new Linear issue."""
    client = get_client()

    # Interactive prompts for missing required fields
    if not title:
        title = questionary.text("Issue title:").ask()
        if not title:
            click.echo("Error: Title is required", err=True)
            sys.exit(1)

    # Fetch teams if not provided via command line
    team_id = None
    if not team:
        try:
            # Fetch available teams
            result = client.execute(LIST_TEAMS_QUERY)
            teams = result.get("teams", {}).get("nodes", [])

            if not teams:
                click.echo("Error: No teams found", err=True)
                sys.exit(1)

            # Create choices for questionary
            choices = [
                questionary.Choice(
                    title=f"{t['key']} - {t['name']}",
                    value=t['id']
                )
                for t in teams
            ]

            team_id = questionary.select(
                "Select team:",
                choices=choices
            ).ask()

            if not team_id:
                click.echo("Error: Team selection is required", err=True)
                sys.exit(1)

        except Exception as e:
            click.echo(f"Error fetching teams: {e}", err=True)
            sys.exit(1)
    else:
        # If team was provided, check if it's a key (like "FLA") or UUID
        if all(c in '0123456789abcdef-' for c in team.lower()):
            # It's a UUID
            team_id = team
        else:
            # It's a team key, fetch the team to get UUID
            try:
                result = client.execute(LIST_TEAMS_QUERY)
                teams = result.get("teams", {}).get("nodes", [])

                # Find team by key
                matching_team = next((t for t in teams if t['key'].lower() == team.lower()), None)

                if matching_team:
                    team_id = matching_team['id']
                else:
                    click.echo(f"Error: Team with key '{team}' not found", err=True)
                    sys.exit(1)

            except Exception as e:
                click.echo(f"Error fetching teams: {e}", err=True)
                sys.exit(1)

    # Optional prompts
    if not description:
        description = questionary.text("Description (optional):").ask() or None

    # Resolve parent issue ID if provided
    parent_id = None
    if parent:
        try:
            parent_id = resolve_issue_id(client, parent)
        except Exception as e:
            click.echo(f"Error resolving parent issue: {e}", err=True)
            sys.exit(1)

    try:
        # Build create input
        input_data: dict[str, Any] = {
            "title": title,
            "teamId": team_id,
        }

        if description:
            input_data["description"] = description
        if parent_id:
            input_data["parentId"] = parent_id
        if assignee:
            input_data["assigneeId"] = assignee
        if priority is not None:
            input_data["priority"] = priority

        # Execute mutation
        result = client.execute(CREATE_ISSUE_MUTATION, variable_values={"input": input_data})

        if result.get("issueCreate", {}).get("success"):
            issue = result["issueCreate"]["issue"]
            click.echo(f"\nIssue created successfully: {issue['identifier']}")
            click.echo(format_issue(issue, detailed=True))
        else:
            click.echo("Error: Failed to create issue", err=True)
            sys.exit(1)

    except TransportQueryError as e:
        click.echo(f"Error creating issue: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


@issue.command("update")
@click.argument("issue_id")
@click.option("--title", help="New title")
@click.option("--description", help="New description")
@click.option("--state", help="New state ID")
@click.option("--assignee", help="New assignee user ID")
@click.option("--priority", type=int, help="New priority (0-4)")
def issue_update(
    issue_id: str,
    title: Optional[str],
    description: Optional[str],
    state: Optional[str],
    assignee: Optional[str],
    priority: Optional[int],
) -> None:
    """Update an existing Linear issue."""
    client = get_client()

    # At least one field must be provided
    if not any([title, description, state, assignee, priority is not None]):
        click.echo("Error: At least one field to update must be provided", err=True)
        click.echo("Use --title, --description, --state, --assignee, or --priority", err=True)
        sys.exit(1)

    try:
        # Resolve human-readable identifier to UUID if needed
        resolved_id = resolve_issue_id(client, issue_id)

        # Build update input
        input_data: dict[str, Any] = {}

        if title:
            input_data["title"] = title
        if description:
            input_data["description"] = description
        if state:
            input_data["stateId"] = state
        if assignee:
            input_data["assigneeId"] = assignee
        if priority is not None:
            input_data["priority"] = priority

        # Execute mutation
        result = client.execute(
            UPDATE_ISSUE_MUTATION,
            variable_values={"id": resolved_id, "input": input_data}
        )

        if result.get("issueUpdate", {}).get("success"):
            issue = result["issueUpdate"]["issue"]
            click.echo(f"\nIssue {issue_id} updated successfully")
            click.echo(format_issue(issue, detailed=True))
        else:
            click.echo("Error: Failed to update issue", err=True)
            sys.exit(1)

    except TransportQueryError as e:
        click.echo(f"Error updating issue: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


@comment.command("list")
@click.argument("issue_id")
def comment_list(issue_id: str) -> None:
    """List comments for a specific issue."""
    client = get_client()

    try:
        # Resolve human-readable identifier to UUID if needed
        resolved_id = resolve_issue_id(client, issue_id)

        # Execute query
        result = client.execute(LIST_COMMENTS_QUERY, variable_values={"issueId": resolved_id})
        comments = result.get("issue", {}).get("comments", {}).get("nodes", [])

        if not comments:
            click.echo("No comments found.")
            return

        click.echo(f"\nComments for issue {issue_id}:")
        click.echo("=" * 80)

        for comment in comments:
            click.echo(format_comment(comment))

        click.echo(f"\nShowing {len(comments)} comment(s)")

    except TransportQueryError as e:
        click.echo(f"Error listing comments: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


@comment.command("create")
@click.argument("issue_id")
@click.option("--message", "-m", help="Comment text")
def comment_create(issue_id: str, message: Optional[str]) -> None:
    """Add a comment to an issue."""
    client = get_client()

    # Interactive prompt if message not provided
    if not message:
        message = questionary.text("Comment:").ask()
        if not message:
            click.echo("Error: Comment text is required", err=True)
            sys.exit(1)

    try:
        # Resolve human-readable identifier to UUID if needed
        resolved_id = resolve_issue_id(client, issue_id)

        # Build input
        input_data = {
            "issueId": resolved_id,
            "body": message,
        }

        # Execute mutation
        result = client.execute(CREATE_COMMENT_MUTATION, variable_values={"input": input_data})

        if result.get("commentCreate", {}).get("success"):
            comment = result["commentCreate"]["comment"]
            click.echo(f"\nComment added to issue {issue_id}:")
            click.echo(format_comment(comment))
        else:
            click.echo("Error: Failed to create comment", err=True)
            sys.exit(1)

    except TransportQueryError as e:
        click.echo(f"Error creating comment: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


if __name__ == "__main__":
    cli()
