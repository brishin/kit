#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "gql[requests]>=3.5.0",
#   "click",
#   "questionary",
#   "python-dotenv",
# ]
# ///
"""
Linear CLI - Manage Linear issues and comments from the command line.

Powered by the Linear GraphQL API.

Usage:
  linear issue list [--assignee USER] [--status STATUS] [--label LABEL]
  linear issue view <issue-id>
  linear issue create
  linear issue update <issue-id> [--status STATUS] [--assignee USER] [--title TITLE]
  linear comment list <issue-id>
  linear comment create <issue-id> [--message MESSAGE]
  linear report cycle --team <TEAM_KEY> [--group-by priority|epic|assignee] [--cycle <CYCLE_ID>] [--include-in-progress]

Setup:
  1. Generate a Personal API Key at: https://linear.app/settings/api
  2. Add to ~/.env.local: LINEAR_API_KEY="lin_api_..."
     (or set environment variable: export LINEAR_API_KEY="lin_api_...")
"""

import sys
import os
import re
import subprocess
from pathlib import Path
from typing import TypedDict, Optional, List, Any, NotRequired

import click
import questionary
from dotenv import load_dotenv
from gql import Client, gql as gql_query
from gql.transport.requests import RequestsHTTPTransport
from gql.transport.exceptions import TransportQueryError

# Load environment variables from ~/.env.local
load_dotenv(dotenv_path=Path.home() / ".env.local")


# ============================================================================
# Type Definitions
# ============================================================================

# Priority is a scalar number (0-4), with separate priorityLabel field


class StatusData(TypedDict):
    id: str
    name: str
    type: NotRequired[str]  # "unstarted", "started", "completed", "canceled"


class UserData(TypedDict):
    id: str
    name: str
    email: NotRequired[str]


class AttachmentData(TypedDict):
    id: str
    title: str
    subtitle: NotRequired[str]
    url: str


class AttachmentsConnection(TypedDict):
    nodes: List[AttachmentData]


class IssueRef(TypedDict):
    """Minimal issue reference (for parent/children)"""
    id: str
    identifier: str
    title: NotRequired[str]
    status: NotRequired[StatusData]
    priority: NotRequired[float]
    priorityLabel: NotRequired[str]
    attachments: NotRequired[AttachmentsConnection]


class ChildrenConnection(TypedDict):
    nodes: List[IssueRef]


class CycleRef(TypedDict):
    """Minimal cycle reference"""
    id: str
    name: str
    number: NotRequired[int]


class IssueData(TypedDict):
    id: str
    identifier: str
    title: str
    description: NotRequired[str]
    priority: NotRequired[float]  # 0-4, where 0 is no priority, 1 is urgent, 4 is low
    priorityLabel: NotRequired[str]  # "Urgent", "High", "Medium", "Low", "No priority"
    status: StatusData
    url: str
    branchName: NotRequired[str]
    createdAt: str
    updatedAt: str
    completedAt: NotRequired[str]  # When the issue was completed
    estimate: NotRequired[float]  # Story points
    assignee: NotRequired[UserData]
    creator: NotRequired[UserData]
    project: NotRequired[dict[str, str]]
    team: NotRequired[dict[str, str]]
    parent: NotRequired[IssueRef]
    children: NotRequired[ChildrenConnection]
    attachments: NotRequired[AttachmentsConnection]
    cycle: NotRequired[CycleRef]


class CommentData(TypedDict):
    id: str
    body: str
    createdAt: str
    user: UserData


class TeamData(TypedDict):
    id: str
    name: str
    key: str


class IssuesConnection(TypedDict):
    """Connection type for issues with pagination support"""
    nodes: List[IssueData]
    pageInfo: NotRequired[dict[str, Any]]


class CycleData(TypedDict):
    """Full cycle data with progress metrics"""
    id: str
    name: str
    number: int
    startsAt: str
    endsAt: str
    isActive: bool
    progress: NotRequired[float]  # 0.0 to 1.0
    scopeHistory: NotRequired[List[float]]
    completedScopeHistory: NotRequired[List[float]]
    issueCountHistory: NotRequired[List[float]]
    issues: NotRequired[IssuesConnection]
    team: NotRequired[TeamData]


# ============================================================================
# GraphQL Client
# ============================================================================

_client_cache: Optional[Client] = None


def get_client() -> Client:
    """Get or create GraphQL client connection."""
    global _client_cache

    if _client_cache is not None:
        return _client_cache

    api_key = os.environ.get("LINEAR_API_KEY")
    if not api_key:
        click.echo("Error: LINEAR_API_KEY not found", err=True)
        click.echo("\nTo get an API key:", err=True)
        click.echo("  1. Go to https://linear.app/settings/api", err=True)
        click.echo("  2. Create a new Personal API Key", err=True)
        click.echo("  3. Add to ~/.env.local: LINEAR_API_KEY='lin_api_...'", err=True)
        click.echo("     (or set environment variable: export LINEAR_API_KEY='lin_api_...')", err=True)
        sys.exit(1)

    # Create transport with API key authentication
    transport = RequestsHTTPTransport(
        url="https://api.linear.app/graphql",
        headers={"Authorization": api_key},
        verify=True,
        retries=3,
    )

    # Create and cache the client
    _client_cache = Client(transport=transport, fetch_schema_from_transport=False)
    return _client_cache


# ============================================================================
# GraphQL Queries
# ============================================================================

LIST_ISSUES_QUERY = gql_query("""
query ListIssues($first: Int!) {
  issues(first: $first, orderBy: updatedAt) {
    nodes {
      id
      identifier
      title
      description
      status: state { id name }
      priority
      priorityLabel
      url
      parent { id identifier title }
      children(first: 50) {
        nodes {
          id
          identifier
        }
      }
      attachments {
        nodes {
          id
          title
          subtitle
          url
        }
      }
      assignee { id name }
      createdAt
      updatedAt
      project { id name }
      team { name }
    }
  }
}
""")

GET_ISSUE_QUERY = gql_query("""
query GetIssue($id: String!) {
  issue(id: $id) {
    id
    identifier
    title
    description
    status: state { id name }
    priority
    priorityLabel
    url
    branchName
    createdAt
    updatedAt
    parent { id identifier title }
    children(first: 50) {
      nodes {
        id
        identifier
        title
        status: state { id name type }
        priority
        priorityLabel
        attachments {
          nodes {
            id
            title
            subtitle
            url
          }
        }
      }
    }
    attachments {
      nodes {
        id
        title
        subtitle
        url
      }
    }
    assignee { id name email }
    creator { name }
    project { name }
    team { name }
  }
}
""")

LIST_COMMENTS_QUERY = gql_query("""
query ListComments($issueId: String!) {
  issue(id: $issueId) {
    comments {
      nodes {
        id
        body
        createdAt
        user { id name }
      }
    }
  }
}
""")

CREATE_ISSUE_MUTATION = gql_query("""
mutation CreateIssue($input: IssueCreateInput!) {
  issueCreate(input: $input) {
    success
    issue {
      id
      identifier
      title
      description
      status: state { id name }
      priority
      priorityLabel
    }
  }
}
""")

UPDATE_ISSUE_MUTATION = gql_query("""
mutation UpdateIssue($id: String!, $input: IssueUpdateInput!) {
  issueUpdate(id: $id, input: $input) {
    success
    issue {
      id
      identifier
      title
      description
      status: state { id name }
      priority
      priorityLabel
    }
  }
}
""")

CREATE_COMMENT_MUTATION = gql_query("""
mutation CreateComment($input: CommentCreateInput!) {
  commentCreate(input: $input) {
    success
    comment {
      id
      body
      createdAt
      user { id name }
    }
  }
}
""")

LIST_TEAMS_QUERY = gql_query("""
query ListTeams {
  teams {
    nodes {
      id
      name
      key
    }
  }
}
""")

GET_ACTIVE_CYCLE_QUERY = gql_query("""
query GetActiveCycle($teamId: String!) {
  team(id: $teamId) {
    id
    name
    key
    activeCycle {
      id
      name
      number
      startsAt
      endsAt
      isActive
      progress
    }
  }
}
""")

GET_CYCLE_WITH_ISSUES_QUERY = gql_query("""
query GetCycleWithIssues($cycleId: String!, $filter: IssueFilter) {
  cycle(id: $cycleId) {
    id
    name
    number
    startsAt
    endsAt
    isActive
    progress
    team {
      id
      name
      key
    }
    issues(first: 250, filter: $filter) {
      nodes {
        id
        identifier
        title
        description
        priority
        priorityLabel
        status: state {
          id
          name
          type
        }
        completedAt
        estimate
        url
        assignee {
          id
          name
        }
        parent {
          id
          identifier
          title
        }
        attachments {
          nodes {
            id
            title
            subtitle
            url
          }
        }
      }
    }
  }
}
""")

LIST_ISSUES_WITH_FILTER_QUERY = gql_query("""
query ListIssuesWithFilter($first: Int!, $filter: IssueFilter) {
  issues(first: $first, orderBy: updatedAt, filter: $filter) {
    nodes {
      id
      identifier
      title
      description
      priority
      priorityLabel
      status: state {
        id
        name
        type
      }
      completedAt
      estimate
      url
      assignee {
        id
        name
      }
      parent {
        id
        identifier
        title
      }
      cycle {
        id
        name
        number
      }
      attachments {
        nodes {
          id
          title
          subtitle
          url
        }
      }
    }
  }
}
""")


# ============================================================================
# Helper Functions
# ============================================================================

def resolve_issue_id(client: Client, identifier_or_id: str) -> str:
    """
    Resolve a human-readable identifier (e.g., 'FLA-123') to a UUID.
    If already a UUID, returns it as-is.
    """
    # Check if it's already a UUID (contains only hex chars and dashes)
    if all(c in '0123456789abcdef-' for c in identifier_or_id.lower()):
        return identifier_or_id

    # It's a human-readable identifier, fetch from Linear directly
    # Linear's issue() query accepts identifiers directly
    search_query = gql_query("""
    query GetIssueByIdentifier($id: String!) {
      issue(id: $id) {
        id
        identifier
      }
    }
    """)

    try:
        result = client.execute(search_query, variable_values={"id": identifier_or_id})
        issue = result.get("issue")

        if issue and issue.get("id"):
            return str(issue["id"])

        raise ValueError(f"Could not find issue with identifier: {identifier_or_id}")

    except Exception as e:
        raise ValueError(f"Error resolving issue identifier '{identifier_or_id}': {e}")


def get_priority_icon(priority: Optional[float]) -> str:
    """Get emoji icon for priority level."""
    if priority is None or priority == 0:
        return "âšª"  # No priority

    if priority == 1:
        return "ðŸ”´"  # Urgent
    elif priority == 2:
        return "ðŸŸ "  # High
    elif priority == 3:
        return "ðŸŸ¡"  # Medium
    elif priority == 4:
        return "ðŸŸ¢"  # Low
    else:
        return "âšª"  # Unknown


def count_pr_attachments(attachments: Optional[AttachmentsConnection]) -> int:
    """Count GitHub PR attachments."""
    if not attachments:
        return 0

    nodes = attachments.get("nodes", [])
    return sum(1 for att in nodes if "github.com" in att.get("url", ""))


def count_subissues(children: Optional[ChildrenConnection]) -> int:
    """Count child issues (subissues)."""
    if not children:
        return 0
    return len(children.get("nodes", []))


def get_pr_changed_files(pr_url: str) -> Optional[List[str]]:
    """
    Fetch changed files for a GitHub PR using gh CLI.

    Args:
        pr_url: GitHub PR URL (e.g., https://github.com/owner/repo/pull/123)

    Returns:
        List of changed file paths, or None if fetch fails
    """
    try:
        # Extract owner, repo, and PR number from URL using regex
        # Format: https://github.com/owner/repo/pull/123
        match = re.match(r'https?://github\.com/([^/]+)/([^/]+)/pull/(\d+)', pr_url.rstrip('/'))
        if not match:
            return None

        owner, repo, pr_number = match.groups()

        result = subprocess.run(
            ['gh', 'pr', 'view', pr_number, '--repo', f'{owner}/{repo}', '--json', 'files', '--jq', '.files[].path'],
            capture_output=True,
            text=True,
            timeout=10
        )

        if result.returncode != 0:
            return None

        # Parse output - one file per line
        files = [line.strip() for line in result.stdout.strip().split('\n') if line.strip()]
        return files

    except (subprocess.TimeoutExpired, subprocess.SubprocessError, IndexError):
        return None


def format_pr_files(pr_urls: List[str], show_all_pr_files: bool, indent: str = "  ") -> tuple[List[str], int]:
    """
    Format PR URLs with their changed files.

    Args:
        pr_urls: List of GitHub PR URLs
        show_all_pr_files: Whether to show all files or limit to 20
        indent: Indentation string for the PR URL line

    Returns:
        Tuple of (output_lines, total_files_fetched)
    """
    output: List[str] = []
    file_limit = 20
    total_files_fetched = 0

    for pr_url in pr_urls:
        output.append(f"{indent}- {pr_url}")

        # Check if we should stop fetching (optimization)
        if not show_all_pr_files and total_files_fetched >= file_limit:
            output.append(f"{indent}    (Skipped fetching - already showing {file_limit} files. Use --show-all-pr-files to see all.)")
            continue

        # Fetch changed files for this PR
        changed_files = get_pr_changed_files(pr_url)

        if changed_files:
            total_pr_files = len(changed_files)
            total_files_fetched += total_pr_files

            # Calculate how many files to show from this PR
            if show_all_pr_files:
                files_to_show = changed_files
            else:
                remaining_budget = file_limit - (total_files_fetched - total_pr_files)
                files_to_show = changed_files[:remaining_budget]

            # Display files
            for file_path in files_to_show:
                output.append(f"{indent}    {file_path}")

            # Show truncation message if needed
            if not show_all_pr_files and len(files_to_show) < total_pr_files:
                remaining = total_pr_files - len(files_to_show)
                output.append(f"{indent}    ... and {remaining} more file(s) in this PR. Use --show-all-pr-files to see all.")

        elif changed_files is None:
            output.append(f"{indent}    (Unable to fetch changed files)")
        else:
            output.append(f"{indent}    (No files changed)")

    return output, total_files_fetched


def sort_issues_by_status(issues: List[IssueRef]) -> List[IssueRef]:
    """
    Sort issues by status type, with completed/canceled at the bottom.

    Order: unstarted -> started -> canceled -> completed
    Within each group, sort by most recently updated first.
    """
    # Define sort order for state types
    state_type_order = {
        "unstarted": 0,
        "started": 1,
        "canceled": 2,
        "completed": 3,
    }

    def get_sort_key(issue: IssueRef) -> tuple[int, str]:
        status = issue.get("status")
        state_type = status.get("type", "unstarted") if status else "unstarted"

        # Get priority for state type (lower is higher priority)
        type_priority = state_type_order.get(state_type, 999)

        # Return tuple: (state_type_priority, negative to sort desc by update time if available)
        return (type_priority, "")

    return sorted(issues, key=get_sort_key)


def format_issue_compact(issue_data: IssueData | IssueRef, max_title_len: int = 40, show_parent_project: bool = True) -> str:
    """Format issue in compact one-line view."""
    issue_id = issue_data.get("identifier", "unknown")
    title = issue_data.get("title", "No title")
    status_obj = issue_data.get("status")
    status = status_obj.get("name", "unknown") if status_obj else "unknown"
    priority = issue_data.get("priority")

    priority_icon = get_priority_icon(priority)

    # Truncate title to fit
    title_display = title[:max_title_len] + "..." if len(title) > max_title_len else title

    # Build compact display
    parts = [
        f"[{issue_id}]",
        f"[{status}]",
        f"[{priority_icon}]",
        title_display,
    ]

    # Add metadata indicators (only for full IssueData)
    meta_parts = []

    # Add PR and subissue counts
    # Both IssueData and IssueRef can have attachments field
    attachments_field = issue_data.get("attachments")
    if attachments_field is not None:
        pr_count = count_pr_attachments(attachments_field)
        if pr_count > 0:
            meta_parts.append(f"PRs: {pr_count}")

    children_field = issue_data.get("children")
    if children_field is not None:
        sub_count = count_subissues(children_field)  # type: ignore
        if sub_count > 0:
            meta_parts.append(f"Subs: {sub_count} â†³")

    # Add parent info if available and requested
    if show_parent_project:
        parent = issue_data.get("parent")
        if parent and isinstance(parent, dict):
            parent_id = parent.get("identifier", "unknown")
            meta_parts.append(f"Parent: {parent_id}")

        # Add project info if available
        project = issue_data.get("project")
        if project and isinstance(project, dict):
            project_name = project.get("name")
            if project_name:
                meta_parts.append(f"Project: {project_name}")

    if meta_parts:
        parts.append(f"| {' | '.join(meta_parts)}")

    return " ".join(parts)


def format_issue(issue_data: IssueData, detailed: bool = False, show_all_pr_files: bool = False) -> str:
    """Format issue data for display."""
    issue_id = issue_data.get("identifier", "unknown")
    title = issue_data.get("title", "No title")
    status = issue_data.get("status", {}).get("name", "unknown")
    priority = issue_data.get("priority")

    if detailed:
        # Detailed view
        assignee = issue_data.get("assignee")
        assignee_name = assignee.get("name", "Unassigned") if assignee else "Unassigned"

        description = issue_data.get("description", "No description")
        created_at = issue_data.get("createdAt", "unknown")
        updated_at = issue_data.get("updatedAt", "unknown")
        priority_label = issue_data.get("priorityLabel", "No priority")

        # Parent issue
        parent = issue_data.get("parent")
        parent_str = f"{parent['identifier']}" if parent else "None"

        # Project
        project = issue_data.get("project")
        project_str = project.get("name") if project and isinstance(project, dict) else "None"

        # Children (subissues)
        children_nodes = issue_data.get("children", {}).get("nodes", [])
        # Sort children by status (done/canceled at bottom)
        children_sorted = sort_issues_by_status(children_nodes)

        # PR attachments for main issue
        attachments = issue_data.get("attachments", {}).get("nodes", [])
        pr_links = [att["url"] for att in attachments if "github.com" in att.get("url", "")]

        output = []
        output.append(f"\n{issue_id}: {title}")
        output.append("=" * 80)
        output.append(f"Status: {status}")
        output.append(f"Priority: {priority_label}")
        output.append(f"Assignee: {assignee_name}")
        output.append(f"Project: {project_str}")
        output.append(f"Parent: {parent_str}")
        output.append(f"Created: {created_at}")
        output.append(f"Updated: {updated_at}")

        # Track total files shown across all PRs (main issue + subissues)
        file_limit = 20
        total_files_shown = 0

        # Show main issue PRs first
        if pr_links:
            output.append(f"\nPull Requests:")
            pr_output, files_count = format_pr_files(pr_links, show_all_pr_files, indent="  ")
            output.extend(pr_output)
            total_files_shown += files_count

        # Show subissues
        if children_sorted:
            output.append(f"\nSubissues ({len(children_sorted)}):")

            for child in children_sorted:
                # Don't show parent/project for subissues (redundant in this context)
                output.append(f"  {format_issue_compact(child, max_title_len=60, show_parent_project=False)}")

                # Show PRs for this subissue
                child_attachments = child.get("attachments", {}).get("nodes", []) if isinstance(child.get("attachments"), dict) else []
                child_pr_links = [att["url"] for att in child_attachments if "github.com" in att.get("url", "")]

                if child_pr_links:
                    # Check if we should stop fetching more files
                    if not show_all_pr_files and total_files_shown >= file_limit:
                        # Just show PR URLs without fetching files
                        for pr_url in child_pr_links:
                            output.append(f"    â†’ {pr_url}")
                            output.append(f"        (Skipped fetching - already showing {file_limit} files. Use --show-all-pr-files to see all.)")
                    else:
                        # Format with helper, accounting for budget already used
                        for pr_url in child_pr_links:
                            output.append(f"    â†’ {pr_url}")

                            # Fetch and show files
                            changed_files = get_pr_changed_files(pr_url)

                            if changed_files:
                                total_pr_files = len(changed_files)

                                # Calculate remaining budget
                                if show_all_pr_files:
                                    files_to_show = changed_files
                                else:
                                    remaining_budget = file_limit - total_files_shown
                                    files_to_show = changed_files[:remaining_budget]

                                # Display files
                                for file_path in files_to_show:
                                    output.append(f"        {file_path}")

                                total_files_shown += len(files_to_show)

                                # Show truncation message if needed
                                if not show_all_pr_files and len(files_to_show) < total_pr_files:
                                    remaining = total_pr_files - len(files_to_show)
                                    output.append(f"        ... and {remaining} more file(s) in this PR. Use --show-all-pr-files to see all.")

                            elif changed_files is None:
                                output.append(f"        (Unable to fetch changed files)")
                            else:
                                output.append(f"        (No files changed)")

        output.append(f"\nDescription:")
        output.append(description or "(none)")
        output.append("=" * 80)

        return "\n".join(output)
    else:
        # Compact list view - show parent and project
        return format_issue_compact(issue_data, show_parent_project=True)


def format_comment(comment_data: CommentData) -> str:
    """Format comment data for display."""
    user = comment_data.get("user", {})
    author_name = user.get("name", "Unknown")
    body = comment_data.get("body", "")
    created_at = comment_data.get("createdAt", "unknown")

    return f"\n[{author_name}] {created_at}\n{body}\n{'-' * 40}"


def resolve_team_id(client: Client, team_key: str) -> str:
    """
    Resolve a team key (e.g., 'FLA') to a team UUID.

    Args:
        client: GraphQL client
        team_key: Team key (e.g., 'FLA', 'ENG')

    Returns:
        Team UUID

    Raises:
        ValueError: If team not found
    """
    result = client.execute(LIST_TEAMS_QUERY)
    teams = result.get("teams", {}).get("nodes", [])

    for team in teams:
        if team.get("key", "").upper() == team_key.upper():
            return str(team["id"])

    raise ValueError(f"Could not find team with key: {team_key}")


def get_active_cycle(client: Client, team_id: str) -> Optional[CycleData]:
    """
    Get the active cycle for a team.

    Args:
        client: GraphQL client
        team_id: Team UUID

    Returns:
        CycleData or None if no active cycle
    """
    result = client.execute(GET_ACTIVE_CYCLE_QUERY, variable_values={"teamId": team_id})
    team = result.get("team", {})
    active_cycle = team.get("activeCycle")

    if not active_cycle:
        return None

    # Add team info to cycle data
    active_cycle["team"] = {
        "id": team["id"],
        "name": team["name"],
        "key": team["key"],
    }

    return active_cycle  # type: ignore


def format_issue_for_report(issue: IssueData, show_assignee: bool = True) -> List[str]:
    """
    Format a single issue for inclusion in a report.

    Args:
        issue: Issue data
        show_assignee: Whether to show assignee information

    Returns:
        List of markdown lines for this issue
    """
    lines = []

    # Extract issue details
    identifier = issue.get("identifier", "???")
    title = issue.get("title", "Untitled")
    url = issue.get("url", "")
    assignee_data = issue.get("assignee")
    assignee = assignee_data.get("name", "Unassigned") if assignee_data else "Unassigned"
    description = issue.get("description", "")

    # Get first line of description for context
    context = ""
    if description:
        first_line = description.split("\n")[0].strip()
        if first_line and len(first_line) > 10:
            context = f" - {first_line[:100]}"
            if len(first_line) > 100:
                context += "..."

    # Main issue line
    lines.append(f"- **[{identifier}]({url})** {title}{context}")

    # Show assignee if requested
    if show_assignee and assignee != "Unassigned":
        lines.append(f"  - Owner: @{assignee}")

    # Show PRs if any
    attachments_data = issue.get("attachments")
    attachments = attachments_data.get("nodes", []) if attachments_data else []
    pr_urls = [att["url"] for att in attachments if "github.com" in att.get("url", "")]
    if pr_urls:
        pr_links = ", ".join(f"[#{url.split('/')[-1]}]({url})" for url in pr_urls)
        lines.append(f"  - PRs: {pr_links}")

    lines.append("")
    return lines


def generate_cycle_report_markdown(cycle: CycleData, issues: List[IssueData]) -> str:
    """
    Generate a markdown report for a cycle focusing on key deliverables.

    Args:
        cycle: Cycle data
        issues: List of completed issues in the cycle

    Returns:
        Markdown formatted report
    """
    from datetime import datetime

    # Parse dates
    starts_at = cycle.get("startsAt", "")
    ends_at = cycle.get("endsAt", "")

    try:
        start_date = datetime.fromisoformat(starts_at.replace("Z", "+00:00")).strftime("%Y-%m-%d")
        end_date = datetime.fromisoformat(ends_at.replace("Z", "+00:00")).strftime("%Y-%m-%d")
    except:
        start_date = starts_at
        end_date = ends_at

    team = cycle.get("team", {})
    team_name = team.get("name", "Unknown Team")
    cycle_name = cycle.get("name") or f"Cycle {cycle.get('number', 'Unknown')}"
    cycle_number = cycle.get("number", "")

    # Group issues by priority
    high_priority = [i for i in issues if i.get("priority", 0) in [1, 2]]  # Urgent, High
    medium_priority = [i for i in issues if i.get("priority", 0) == 3]
    low_priority = [i for i in issues if i.get("priority", 0) in [0, 4]]  # No priority, Low

    # Sort by parent issue to group related work
    def sort_key(issue: IssueData) -> tuple[str, str]:
        parent = issue.get("parent", {})
        parent_title = parent.get("title", "") if parent else ""
        return (parent_title, issue.get("identifier", ""))

    high_priority.sort(key=sort_key)
    medium_priority.sort(key=sort_key)
    low_priority.sort(key=sort_key)

    # Build markdown
    lines = [
        f"# Cycle Progress Report: {cycle_name}",
        f"**Team:** {team_name} | **Period:** {start_date} to {end_date}",
        "",
        "## Key Deliverables",
        "",
    ]

    def format_issue_group(priority_issues: List[IssueData], title: str) -> None:
        if not priority_issues:
            return

        lines.append(f"### {title}")
        lines.append("")

        current_parent = None
        for issue in priority_issues:
            parent = issue.get("parent")
            parent_title = parent.get("title") if parent else None

            # Show parent context if it changed
            if parent_title and parent_title != current_parent:
                lines.append(f"**Epic: {parent_title}**")
                lines.append("")
                current_parent = parent_title
            elif not parent_title and current_parent is not None:
                current_parent = None

            # Format issue using helper
            issue_lines = format_issue_for_report(issue, show_assignee=True)
            lines.extend(issue_lines)

    format_issue_group(high_priority, "High Priority")
    format_issue_group(medium_priority, "Medium Priority")
    format_issue_group(low_priority, "Low Priority")

    # Summary
    lines.append("## Summary")
    lines.append("")
    lines.append(f"- **{len(issues)} issues completed**")
    lines.append(f"  - {len(high_priority)} high priority")
    lines.append(f"  - {len(medium_priority)} medium priority")
    lines.append(f"  - {len(low_priority)} low priority")

    # List major projects/epics
    parent_titles = set()
    for issue in issues:
        parent = issue.get("parent")
        if parent and parent.get("title"):
            parent_titles.add(parent["title"])

    if parent_titles:
        lines.append("")
        lines.append("**Major projects:**")
        for parent_title in sorted(parent_titles):
            lines.append(f"- {parent_title}")

    return "\n".join(lines)


def generate_epic_report_markdown(cycle: CycleData, issues: List[IssueData]) -> str:
    """
    Generate a markdown report grouped by epic/parent issue.

    Args:
        cycle: Cycle data
        issues: List of issues in the cycle

    Returns:
        Markdown formatted report
    """
    from datetime import datetime
    from collections import defaultdict

    # Parse dates
    starts_at = cycle.get("startsAt", "")
    ends_at = cycle.get("endsAt", "")

    try:
        start_date = datetime.fromisoformat(starts_at.replace("Z", "+00:00")).strftime("%Y-%m-%d")
        end_date = datetime.fromisoformat(ends_at.replace("Z", "+00:00")).strftime("%Y-%m-%d")
    except:
        start_date = starts_at
        end_date = ends_at

    team = cycle.get("team", {})
    team_name = team.get("name", "Unknown Team")
    cycle_name = cycle.get("name") or f"Cycle {cycle.get('number', 'Unknown')}"

    # Group issues by parent epic
    epic_issues: dict[str, List[IssueData]] = defaultdict(list)
    standalone_issues: List[IssueData] = []

    for issue in issues:
        parent = issue.get("parent")
        if parent and parent.get("title"):
            epic_key = f"{parent['identifier']}||{parent['title']}"  # Use identifier||title as key
            epic_issues[epic_key].append(issue)
        else:
            standalone_issues.append(issue)

    # Sort epics by: (1) highest priority of issues, (2) number of issues
    def epic_sort_key(epic_key: str) -> tuple[float, int]:
        epic_issue_list = epic_issues[epic_key]
        # Get minimum priority value (1 is urgent/highest, 4 is low)
        priorities = [issue.get("priority", 5) for issue in epic_issue_list]
        min_priority = min(priorities) if priorities else 5
        return (min_priority, -len(epic_issue_list))  # Negative for descending count

    sorted_epic_keys = sorted(epic_issues.keys(), key=epic_sort_key)

    # Helper to group issues by priority
    def group_by_priority(issue_list: List[IssueData]) -> tuple[List[IssueData], List[IssueData], List[IssueData]]:
        high = [i for i in issue_list if i.get("priority", 0) in [1, 2]]
        medium = [i for i in issue_list if i.get("priority", 0) == 3]
        low = [i for i in issue_list if i.get("priority", 0) in [0, 4]]
        return high, medium, low

    # Build markdown
    lines = [
        f"# Cycle Progress Report: {cycle_name}",
        f"**Team:** {team_name} | **Period:** {start_date} to {end_date}",
        "",
    ]

    # Major Epics section
    if epic_issues:
        lines.append("## Major Epics")
        lines.append("")

        for epic_key in sorted_epic_keys:
            # Parse epic key
            epic_identifier, epic_title = epic_key.split("||", 1)
            epic_issue_list = epic_issues[epic_key]

            lines.append(f"### [{epic_identifier}] {epic_title} ({len(epic_issue_list)} issues)")
            lines.append("")

            # Group by priority within epic
            high, medium, low = group_by_priority(epic_issue_list)

            if high:
                lines.append(f"**High Priority** ({len(high)} issues)")
                lines.append("")
                for issue in high:
                    issue_lines = format_issue_for_report(issue, show_assignee=True)
                    lines.extend(issue_lines)

            if medium:
                lines.append(f"**Medium Priority** ({len(medium)} issues)")
                lines.append("")
                for issue in medium:
                    issue_lines = format_issue_for_report(issue, show_assignee=True)
                    lines.extend(issue_lines)

            if low:
                lines.append(f"**Low Priority** ({len(low)} issues)")
                lines.append("")
                for issue in low:
                    issue_lines = format_issue_for_report(issue, show_assignee=True)
                    lines.extend(issue_lines)

    # Standalone Issues section
    if standalone_issues:
        lines.append("## Standalone Issues")
        lines.append("")

        high, medium, low = group_by_priority(standalone_issues)

        if high:
            lines.append("### High Priority")
            lines.append("")
            for issue in high:
                issue_lines = format_issue_for_report(issue, show_assignee=True)
                lines.extend(issue_lines)

        if medium:
            lines.append("### Medium Priority")
            lines.append("")
            for issue in medium:
                issue_lines = format_issue_for_report(issue, show_assignee=True)
                lines.extend(issue_lines)

        if low:
            lines.append("### Low Priority")
            lines.append("")
            for issue in low:
                issue_lines = format_issue_for_report(issue, show_assignee=True)
                lines.extend(issue_lines)

    # Summary
    lines.append("## Summary")
    lines.append("")
    if epic_issues:
        lines.append(f"- **{len(epic_issues)} epics** with completed work")
    if standalone_issues:
        lines.append(f"- **{len(standalone_issues)} standalone issues** completed")
    lines.append(f"- **{len(issues)} total issues** completed")

    return "\n".join(lines)


def generate_assignee_report_markdown(cycle: CycleData, issues: List[IssueData]) -> str:
    """
    Generate a markdown report grouped by assignee/team member.

    Args:
        cycle: Cycle data
        issues: List of issues in the cycle

    Returns:
        Markdown formatted report
    """
    from datetime import datetime
    from collections import defaultdict

    # Parse dates
    starts_at = cycle.get("startsAt", "")
    ends_at = cycle.get("endsAt", "")

    try:
        start_date = datetime.fromisoformat(starts_at.replace("Z", "+00:00")).strftime("%Y-%m-%d")
        end_date = datetime.fromisoformat(ends_at.replace("Z", "+00:00")).strftime("%Y-%m-%d")
    except:
        start_date = starts_at
        end_date = ends_at

    team = cycle.get("team", {})
    team_name = team.get("name", "Unknown Team")
    cycle_name = cycle.get("name") or f"Cycle {cycle.get('number', 'Unknown')}"

    # Group issues by assignee
    assignee_issues: dict[str, List[IssueData]] = defaultdict(list)

    for issue in issues:
        assignee_data = issue.get("assignee")
        assignee_name = assignee_data.get("name", "Unassigned") if assignee_data else "Unassigned"
        assignee_issues[assignee_name].append(issue)

    # Sort assignees by number of issues (descending), unassigned last
    def assignee_sort_key(assignee_name: str) -> tuple[int, int, str]:
        is_unassigned = 1 if assignee_name == "Unassigned" else 0
        issue_count = -len(assignee_issues[assignee_name])  # Negative for descending
        return (is_unassigned, issue_count, assignee_name)

    sorted_assignees = sorted(assignee_issues.keys(), key=assignee_sort_key)

    # Build markdown
    lines = [
        f"# Cycle Progress Report: {cycle_name}",
        f"**Team:** {team_name} | **Period:** {start_date} to {end_date}",
        "",
        "## Team Contributions",
        "",
    ]

    for assignee_name in sorted_assignees:
        assignee_issue_list = assignee_issues[assignee_name]
        issue_count = len(assignee_issue_list)

        # Header for this person
        if assignee_name == "Unassigned":
            lines.append(f"### Unassigned ({issue_count} issues)")
        else:
            lines.append(f"### @{assignee_name} ({issue_count} issues)")
        lines.append("")

        # Group this person's issues by epic
        epic_issues: dict[str, List[IssueData]] = defaultdict(list)
        standalone_issues: List[IssueData] = []

        for issue in assignee_issue_list:
            parent = issue.get("parent")
            if parent and parent.get("title"):
                epic_key = f"{parent['identifier']}||{parent['title']}"
                epic_issues[epic_key].append(issue)
            else:
                standalone_issues.append(issue)

        # Sort epics by number of issues (descending)
        sorted_epic_keys = sorted(epic_issues.keys(), key=lambda k: -len(epic_issues[k]))

        # Show epic-grouped issues
        for epic_key in sorted_epic_keys:
            epic_identifier, epic_title = epic_key.split("||", 1)
            epic_issue_list = epic_issues[epic_key]

            lines.append(f"**Epic: [{epic_identifier}] {epic_title}** ({len(epic_issue_list)} issues)")
            lines.append("")

            for issue in epic_issue_list:
                # Don't show assignee since we're already grouped by assignee
                issue_lines = format_issue_for_report(issue, show_assignee=False)
                lines.extend(issue_lines)

        # Show standalone issues
        if standalone_issues:
            lines.append(f"**Standalone Work** ({len(standalone_issues)} issues)")
            lines.append("")

            for issue in standalone_issues:
                issue_lines = format_issue_for_report(issue, show_assignee=False)
                lines.extend(issue_lines)

    # Summary
    lines.append("## Summary")
    lines.append("")

    assigned_count = sum(len(issues) for name, issues in assignee_issues.items() if name != "Unassigned")
    unassigned_count = len(assignee_issues.get("Unassigned", []))
    contributor_count = len([name for name in assignee_issues.keys() if name != "Unassigned"])

    lines.append(f"- **{contributor_count} team members** contributed")
    lines.append(f"- **{assigned_count} assigned issues** completed")
    if unassigned_count > 0:
        lines.append(f"- **{unassigned_count} unassigned issues** completed")
    lines.append(f"- **{len(issues)} total issues** completed")

    # Top contributors
    if contributor_count > 0:
        lines.append("")
        lines.append("**Top contributors:**")
        top_assignees = [name for name in sorted_assignees if name != "Unassigned"][:5]  # Top 5
        for name in top_assignees:
            count = len(assignee_issues[name])
            lines.append(f"- @{name}: {count} issues")

    return "\n".join(lines)


# ============================================================================
# CLI Commands
# ============================================================================

@click.group()
def cli() -> None:
    """Linear CLI - Manage Linear issues and comments."""
    pass


@cli.group()
def issue() -> None:
    """Manage Linear issues."""
    pass


@cli.group()
def comment() -> None:
    """Manage issue comments."""
    pass


@cli.group()
def report() -> None:
    """Generate progress reports."""
    pass


@issue.command("list")
@click.option("--assignee", help="Filter by assignee user ID or name")
@click.option("--state", help="Filter by state (status)")
@click.option("--label", help="Filter by label")
@click.option("--team", help="Filter by team key")
@click.option("--limit", type=int, default=50, help="Maximum number of issues to return (default: 50)")
def issue_list(
    assignee: Optional[str],
    state: Optional[str],
    label: Optional[str],
    team: Optional[str],
    limit: int,
) -> None:
    """List Linear issues with optional filtering."""
    client = get_client()

    try:
        # TODO: Add support for filters (assignee, state, label, team)
        # Linear's GraphQL API has complex filter syntax that needs to be handled properly
        if any([assignee, state, label, team]):
            click.echo("Note: Filtering options are not yet implemented. Showing all issues.", err=True)

        # Execute query
        variables: dict[str, Any] = {"first": limit}
        result = client.execute(LIST_ISSUES_QUERY, variable_values=variables)
        issues = result.get("issues", {}).get("nodes", [])

        if not issues:
            click.echo("No issues found.")
            return

        # Display issues
        click.echo()
        for issue in issues:
            click.echo(format_issue(issue, detailed=False))

        click.echo(f"\nShowing {len(issues)} issue(s)")

    except TransportQueryError as e:
        click.echo(f"Error: GraphQL query failed: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


@issue.command("view")
@click.argument("issue_id")
@click.option("--show-all-pr-files", is_flag=True, help="Show all changed files for PRs (default: limited to 20)")
def issue_view(issue_id: str, show_all_pr_files: bool) -> None:
    """View detailed information about a specific issue."""
    client = get_client()

    try:
        # Resolve human-readable identifier to UUID if needed
        resolved_id = resolve_issue_id(client, issue_id)

        # Execute query
        result = client.execute(GET_ISSUE_QUERY, variable_values={"id": resolved_id})
        issue = result.get("issue")

        if not issue:
            click.echo(f"Error: Issue {issue_id} not found", err=True)
            sys.exit(1)

        click.echo(format_issue(issue, detailed=True, show_all_pr_files=show_all_pr_files))

    except TransportQueryError as e:
        click.echo(f"Error: Issue not found or access denied: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


@issue.command("create")
@click.option("--title", help="Issue title")
@click.option("--description", help="Issue description")
@click.option("--team", help="Team ID or key (e.g., FLA)")
@click.option("--parent", help="Parent issue ID (to create a subtask)")
@click.option("--assignee", help="Assignee user ID")
@click.option("--priority", type=int, help="Priority (0-4)")
def issue_create(
    title: Optional[str],
    description: Optional[str],
    team: Optional[str],
    parent: Optional[str],
    assignee: Optional[str],
    priority: Optional[int],
) -> None:
    """Create a new Linear issue."""
    client = get_client()

    # Interactive prompts for missing required fields
    if not title:
        title = questionary.text("Issue title:").ask()
        if not title:
            click.echo("Error: Title is required", err=True)
            sys.exit(1)

    # Fetch teams if not provided via command line
    team_id = None
    if not team:
        try:
            # Fetch available teams
            result = client.execute(LIST_TEAMS_QUERY)
            teams = result.get("teams", {}).get("nodes", [])

            if not teams:
                click.echo("Error: No teams found", err=True)
                sys.exit(1)

            # Create choices for questionary
            choices = [
                questionary.Choice(
                    title=f"{t['key']} - {t['name']}",
                    value=t['id']
                )
                for t in teams
            ]

            team_id = questionary.select(
                "Select team:",
                choices=choices
            ).ask()

            if not team_id:
                click.echo("Error: Team selection is required", err=True)
                sys.exit(1)

        except Exception as e:
            click.echo(f"Error fetching teams: {e}", err=True)
            sys.exit(1)
    else:
        # If team was provided, check if it's a key (like "FLA") or UUID
        if all(c in '0123456789abcdef-' for c in team.lower()):
            # It's a UUID
            team_id = team
        else:
            # It's a team key, fetch the team to get UUID
            try:
                result = client.execute(LIST_TEAMS_QUERY)
                teams = result.get("teams", {}).get("nodes", [])

                # Find team by key
                matching_team = next((t for t in teams if t['key'].lower() == team.lower()), None)

                if matching_team:
                    team_id = matching_team['id']
                else:
                    click.echo(f"Error: Team with key '{team}' not found", err=True)
                    sys.exit(1)

            except Exception as e:
                click.echo(f"Error fetching teams: {e}", err=True)
                sys.exit(1)

    # Optional prompts
    if not description:
        description = questionary.text("Description (optional):").ask() or None

    # Resolve parent issue ID if provided
    parent_id = None
    if parent:
        try:
            parent_id = resolve_issue_id(client, parent)
        except Exception as e:
            click.echo(f"Error resolving parent issue: {e}", err=True)
            sys.exit(1)

    try:
        # Build create input
        input_data: dict[str, Any] = {
            "title": title,
            "teamId": team_id,
        }

        if description:
            input_data["description"] = description
        if parent_id:
            input_data["parentId"] = parent_id
        if assignee:
            input_data["assigneeId"] = assignee
        if priority is not None:
            input_data["priority"] = priority

        # Execute mutation
        result = client.execute(CREATE_ISSUE_MUTATION, variable_values={"input": input_data})

        if result.get("issueCreate", {}).get("success"):
            issue = result["issueCreate"]["issue"]
            click.echo(f"\nIssue created successfully: {issue['identifier']}")
            click.echo(format_issue(issue, detailed=True))
        else:
            click.echo("Error: Failed to create issue", err=True)
            sys.exit(1)

    except TransportQueryError as e:
        click.echo(f"Error creating issue: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


@issue.command("update")
@click.argument("issue_id")
@click.option("--title", help="New title")
@click.option("--description", help="New description")
@click.option("--state", help="New state ID")
@click.option("--assignee", help="New assignee user ID")
@click.option("--priority", type=int, help="New priority (0-4)")
def issue_update(
    issue_id: str,
    title: Optional[str],
    description: Optional[str],
    state: Optional[str],
    assignee: Optional[str],
    priority: Optional[int],
) -> None:
    """Update an existing Linear issue."""
    client = get_client()

    # At least one field must be provided
    if not any([title, description, state, assignee, priority is not None]):
        click.echo("Error: At least one field to update must be provided", err=True)
        click.echo("Use --title, --description, --state, --assignee, or --priority", err=True)
        sys.exit(1)

    try:
        # Resolve human-readable identifier to UUID if needed
        resolved_id = resolve_issue_id(client, issue_id)

        # Build update input
        input_data: dict[str, Any] = {}

        if title:
            input_data["title"] = title
        if description:
            input_data["description"] = description
        if state:
            input_data["stateId"] = state
        if assignee:
            input_data["assigneeId"] = assignee
        if priority is not None:
            input_data["priority"] = priority

        # Execute mutation
        result = client.execute(
            UPDATE_ISSUE_MUTATION,
            variable_values={"id": resolved_id, "input": input_data}
        )

        if result.get("issueUpdate", {}).get("success"):
            issue = result["issueUpdate"]["issue"]
            click.echo(f"\nIssue {issue_id} updated successfully")
            click.echo(format_issue(issue, detailed=True))
        else:
            click.echo("Error: Failed to update issue", err=True)
            sys.exit(1)

    except TransportQueryError as e:
        click.echo(f"Error updating issue: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


@comment.command("list")
@click.argument("issue_id")
def comment_list(issue_id: str) -> None:
    """List comments for a specific issue."""
    client = get_client()

    try:
        # Resolve human-readable identifier to UUID if needed
        resolved_id = resolve_issue_id(client, issue_id)

        # Execute query
        result = client.execute(LIST_COMMENTS_QUERY, variable_values={"issueId": resolved_id})
        comments = result.get("issue", {}).get("comments", {}).get("nodes", [])

        if not comments:
            click.echo("No comments found.")
            return

        click.echo(f"\nComments for issue {issue_id}:")
        click.echo("=" * 80)

        for comment in comments:
            click.echo(format_comment(comment))

        click.echo(f"\nShowing {len(comments)} comment(s)")

    except TransportQueryError as e:
        click.echo(f"Error listing comments: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


@comment.command("create")
@click.argument("issue_id")
@click.option("--message", "-m", help="Comment text")
def comment_create(issue_id: str, message: Optional[str]) -> None:
    """Add a comment to an issue."""
    client = get_client()

    # Interactive prompt if message not provided
    if not message:
        message = questionary.text("Comment:").ask()
        if not message:
            click.echo("Error: Comment text is required", err=True)
            sys.exit(1)

    try:
        # Resolve human-readable identifier to UUID if needed
        resolved_id = resolve_issue_id(client, issue_id)

        # Build input
        input_data = {
            "issueId": resolved_id,
            "body": message,
        }

        # Execute mutation
        result = client.execute(CREATE_COMMENT_MUTATION, variable_values={"input": input_data})

        if result.get("commentCreate", {}).get("success"):
            comment = result["commentCreate"]["comment"]
            click.echo(f"\nComment added to issue {issue_id}:")
            click.echo(format_comment(comment))
        else:
            click.echo("Error: Failed to create comment", err=True)
            sys.exit(1)

    except TransportQueryError as e:
        click.echo(f"Error creating comment: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


@report.command("cycle")
@click.option("--team", required=True, help="Team key (e.g., FLA, ENG)")
@click.option("--cycle", "cycle_id", help="Cycle ID (defaults to active cycle)")
@click.option("--include-in-progress", is_flag=True, help="Include in-progress issues in addition to completed")
@click.option("--group-by", type=click.Choice(["priority", "epic", "assignee"], case_sensitive=False), default="priority", help="How to group issues in the report (default: priority)")
def report_cycle(team: str, cycle_id: Optional[str], include_in_progress: bool, group_by: str) -> None:
    """
    Generate a markdown progress report for a cycle.

    Grouping options:
    - priority: Group by priority level, then by parent epic (default)
    - epic: Group by parent epic, then by priority within each epic
    - assignee: Group by team member, then by epic within each person

    By default, only shows completed issues. Use --include-in-progress to also show work in progress.

    Examples:
        linear report cycle --team FLA
        linear report cycle --team FLA --group-by epic
        linear report cycle --team FLA --group-by assignee
        linear report cycle --team FLA --group-by assignee --include-in-progress
    """
    try:
        client = get_client()

        # Resolve team ID
        try:
            team_id = resolve_team_id(client, team)
        except ValueError as e:
            click.echo(f"Error: {e}", err=True)
            click.echo("\nAvailable teams:", err=True)
            result = client.execute(LIST_TEAMS_QUERY)
            for t in result.get("teams", {}).get("nodes", []):
                click.echo(f"  - {t['key']}: {t['name']}", err=True)
            sys.exit(1)

        # Get cycle (active or specified)
        if cycle_id:
            # Use specific cycle
            result = client.execute(
                GET_CYCLE_WITH_ISSUES_QUERY,
                variable_values={
                    "cycleId": cycle_id,
                    "filter": None,  # We'll filter after fetching
                }
            )
            cycle = result.get("cycle")
            if not cycle:
                click.echo(f"Error: Cycle not found: {cycle_id}", err=True)
                sys.exit(1)
        else:
            # Use active cycle
            cycle_data = get_active_cycle(client, team_id)
            if not cycle_data:
                click.echo(f"Error: No active cycle found for team {team}", err=True)
                sys.exit(1)

            # Fetch full cycle with issues
            result = client.execute(
                GET_CYCLE_WITH_ISSUES_QUERY,
                variable_values={
                    "cycleId": cycle_data["id"],
                    "filter": None,  # We'll filter after fetching
                }
            )
            cycle = result.get("cycle")

        if not cycle:
            click.echo("Error: Failed to fetch cycle data", err=True)
            sys.exit(1)

        # Get issues from cycle
        all_issues = cycle.get("issues", {}).get("nodes", [])

        # Filter issues by state
        if include_in_progress:
            # Include both completed and started issues
            filtered_issues = [
                issue for issue in all_issues
                if issue.get("status", {}).get("type") in ["completed", "started"]
            ]
        else:
            # Only completed issues
            filtered_issues = [
                issue for issue in all_issues
                if issue.get("status", {}).get("type") == "completed"
            ]

        if not filtered_issues:
            state_msg = "completed or in-progress" if include_in_progress else "completed"
            click.echo(f"No {state_msg} issues found in cycle {cycle['name']}", err=True)
            sys.exit(0)

        # Generate markdown report based on grouping preference
        if group_by.lower() == "epic":
            markdown = generate_epic_report_markdown(cycle, filtered_issues)
        elif group_by.lower() == "assignee":
            markdown = generate_assignee_report_markdown(cycle, filtered_issues)
        else:  # Default: priority
            markdown = generate_cycle_report_markdown(cycle, filtered_issues)

        # Output to stdout
        click.echo(markdown)

    except TransportQueryError as e:
        click.echo(f"Error fetching cycle data: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    cli()
